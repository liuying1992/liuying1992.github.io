<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>黎伟杰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android">
<meta property="og:type" content="website">
<meta property="og:title" content="黎伟杰">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="黎伟杰">
<meta property="og:description" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黎伟杰">
<meta name="twitter:description" content="Android">
  
    <link rel="alternate" href="/atom.xml" title="黎伟杰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">黎伟杰</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-gradle/gradle-java1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/07/gradle/gradle-java1/" class="article-date">
  <time datetime="2016-11-07T14:42:18.088Z" itemprop="datePublished">2016-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/gradle/">gradle</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/gradle/gradle-java1/">Gradle构建java程序一</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Gradle构建Java"><a href="#Gradle构建Java" class="headerlink" title="Gradle构建Java"></a>Gradle构建Java</h1><h2 id="配置Gradle环境"><a href="#配置Gradle环境" class="headerlink" title="配置Gradle环境"></a>配置Gradle环境</h2><ol>
<li>下载gradle的二进制文件，<a href="https://gradle.org/gradle-download/" target="_blank" rel="external">GRADLE 3.1</a>，最新版本是3.1</li>
<li>配置环境变量<br>在环境变量中添加gradle安装目录，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\software\gradle\gradle-3.1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后在path变量中添加进入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%GRADLE_HOME%\bin</div></pre></td></tr></table></figure></p>
<p>然后在命令行输入gradle -v查看是否有正确数据。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">src</div><div class="line">    -main</div><div class="line">        -java</div><div class="line">        -resource</div><div class="line">    -test</div><div class="line">        -java</div><div class="line">        -resource</div><div class="line">build.gradle</div></pre></td></tr></table></figure>
<h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><p>biuld.gradle目录需要跟src目录同级，然后在build中添加gradle的java插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;java&apos;</div></pre></td></tr></table></figure></p>
<p>然后在main/java/ 目录下面写代码<br>比如包名是：com.test.java，然后就依次建立这个文件夹，然后建立Java文件，比如建立HelloWorld.java，内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.test.java</div><div class="line"> </div><div class="line">public class HelloWorld &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;Hello World!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，在跟目录，也就是src和build那里，运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle assemble</div></pre></td></tr></table></figure></p>
<p>然后看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BUILD SUCCESSFUL</div></pre></td></tr></table></figure></p>
<p>就是构建成功了。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>他会在根目录下面生成一个build的文件夹，那些是构建的结果，其中</p>
<ol>
<li>build.libs/目录下是生成可以在别处用的jar文件。jar的名字是[projectName].java，就是src所在的parent目录的名字。</li>
<li>build/classes 是生成的字节码文件。<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2>通用的task<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">assemble</div><div class="line">check</div><div class="line">build</div><div class="line">clean</div></pre></td></tr></table></figure>
</li>
</ol>
<p>添加java plugin的时候，他会自动的带有上面的 四个命令。</p>
<ol>
<li>assemble 组合项目所有输出任务，就是只是回去执行项目打包所需要的任务集</li>
<li>check 执行所有检查任务</li>
<li>build 执行 assemble 和 check 两个 task 的所有工作</li>
<li>clean 会清空项目的输出<br>来源：<a href="https://chaosleong.gitbooks.io/gradle-for-android/content/basic_project_setup/build_tasks/general_tasks.html" target="_blank" rel="external">通用 Task</a></li>
</ol>
<p>需要运行出一个java程序，我们需要配置杂builde.gradle中加入Manifest，设置我们的入口类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;java&apos;</div><div class="line">jar &#123;</div><div class="line">    manifest &#123;</div><div class="line">        attributes &apos;Main-Class&apos;: &apos;com.test.java.HelloWorld&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，再次进行打包，使用assemble 或者build命令，生成jar，然后，cd到build的libs文件夹下面，使用java -jar xxx.jar命令。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java jar test.jar</div></pre></td></tr></table></figure></p>
<p>然后，就可以看到hello word了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/11/07/gradle/gradle-java1/" data-id="civ9mcpgu0004fwoua1x1ja5w" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gradle构建/">gradle构建</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/开源项目学习/RxJavacmd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/26/Android/开源项目学习/RxJavacmd/" class="article-date">
  <time datetime="2016-10-26T15:34:11.589Z" itemprop="datePublished">2016-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/开源项目学习/">开源项目学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/26/Android/开源项目学习/RxJavacmd/">RxJava全部操作符例子</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="RXJava好处"><a href="#RXJava好处" class="headerlink" title="RXJava好处"></a>RXJava好处</h4><p>流行框架，流处理，逻辑清晰，网络处理方便，不再使用Handler，异步操作，简洁，哪怕是逻辑上面复杂，代码程度上面也能够做到简洁，与Retrofit2.0完美结合，多操作符。</p>
<h5 id="RXJava相关依赖"><a href="#RXJava相关依赖" class="headerlink" title="RXJava相关依赖"></a>RXJava相关依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile &apos;io.reactivex:rxjava:1.1.6&apos;</div><div class="line">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</div></pre></td></tr></table></figure>
<h4 id="RXJava的使用"><a href="#RXJava的使用" class="headerlink" title="RXJava的使用"></a>RXJava的使用</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>RxJava基于的是观察者模式，类似订阅-发布，也类似Android的View的一些Listener监听<br>主要是有下面三个概念</p>
<ol>
<li>Observable 被观察者</li>
<li>Observer 观察者，是一个接口</li>
<li>Subscriber 观察者，继承自Observer，一般使用这个</li>
<li>Subject 即时观察者也是被观察者，适合公共资源共享传递，比如做RxBus时候。<br>观察者与被观察之间是通过subscribe()方法联系起来。与一般的逻辑相反的是，这里是Observable.subscribe(Observer/Subscriber)<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5></li>
<li>建Observable对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;hello RxJava&quot;);</div><div class="line">                subscriber.onNext(&quot;hi&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>2 创建Subscriber<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void onCompleted() &#123;</div><div class="line">            Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onError(Throwable e) &#123;</div><div class="line">            Log.i(TAG, e.getMessage());</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onNext(String s) &#123;</div><div class="line">            Log.i(TAG, s);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>3 两者关联起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(subscriber);</div></pre></td></tr></table></figure></p>
<p>4 运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hello RxJava</div><div class="line">hi</div><div class="line">onCompleted</div></pre></td></tr></table></figure></p>
<h5 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h5><h6 id="Observable，就是一个需要被观察的对象，序列，生成的方式"><a href="#Observable，就是一个需要被观察的对象，序列，生成的方式" class="headerlink" title="Observable，就是一个需要被观察的对象，序列，生成的方式"></a><strong><em>Observable，就是一个需要被观察的对象，序列，生成的方式</em></strong></h6><p>   首先，.Observable是什么东西已经知道了，在RxJava里面，他是最基本的类，1W多行ORZ，创建Observable的方式有很多种</p>
<h6 id="create"><a href="#create" class="headerlink" title="create"></a><strong>create</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable.create(OnSubscribe)</div></pre></td></tr></table></figure>
<p>OnSubcribe是一个了是Listener之类的东西，暂时不管，只是知道他有一个call方法，可以通过该call方法回调Subscriber的onNext，onComplete，onError方法。<br> <img src="http://reactivex.io/documentation/operators/images/create.c.png" alt=""></p>
<h6 id="just"><a href="#just" class="headerlink" title="just"></a><strong>just</strong></h6><p>他可以接收1~9个参数，例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void onCompleted() &#123;</div><div class="line">              Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onError(Throwable e) &#123;</div><div class="line"> </div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onNext(String s) &#123;</div><div class="line">              Log.i(TAG, s);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>他会依次调用Subscriber的onNext，onNext,onComplete/onError，这里会打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line">C</div><div class="line">onCompleted</div></pre></td></tr></table></figure></p>
<p>他的OnSubscribe类型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnSubscribeFromArray--&gt;数组</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/just.png" alt=""></p>
<h6 id="from"><a href="#from" class="headerlink" title="from"></a><strong>from</strong></h6><p>接收一个Iterable对象(集合List)或者是数组对象，或者是一个线程的Future，例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.from(new String[]&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void call(String s) &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>他的 OnSubscribe类型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OnSubscribeFromIterable --&gt;Iterable</div><div class="line">OnSubscribeFromArray --&gt;数组</div><div class="line">ToObservableFuture --&gt; Future</div></pre></td></tr></table></figure></p>
<p>从这里可以看出，just是最终的实现是调用了from操作符。<br><img src="http://reactivex.io/documentation/operators/images/from.c.png" alt=""></p>
<h6 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a><strong>Defer</strong></h6><p>直到有订阅者倍subscribe的时候才会创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">str = &quot;Hello，RxJava&quot;;</div><div class="line">       Observable&lt;String&gt; observable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;String&gt; call() &#123;</div><div class="line">               return Observable.just(str);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       str = &quot;hi，RxJava&quot;;</div><div class="line">       observable.subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hi，RxJava</div></pre></td></tr></table></figure></p>
<p>当你使用别的操作符去生成observable的时候发现会是“Hello，RxJava”<br>他的OnSubscribe类型是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnSubscribeDefer --&gt; 泛型</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/defer.c.png" alt=""></p>
<h6 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a><strong>Interval</strong></h6><p>固定时间间隔发送整数序列的Observable，类似一个计数器，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> Observable.interval(1, TimeUnit.SECONDS,Schedulers.io()).subscribe(new Action1&lt;Long&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void call(Long aLong) &#123;</div><div class="line">        Log.i(TAG, String.valueOf(aLong));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>需要注意的是：在Android，在UI线程中去使用，需要制定interval的调度器<br>参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//第一个参数是延时多久开始，第二个参数是每隔多久计时，第三个参数是计时类型，比如TimeUnit .SECONDS,TimeUnit.HOURS等，第四个是调度器，其他重载的方法类似</div><div class="line">Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit,Schedulers scheduler)</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/interval.c.png" alt=""></p>
<h6 id="range"><a href="#range" class="headerlink" title="range"></a><strong>range</strong></h6><p>创建一个特定序列的Observable，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 5).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>当然你也可以知道调度器。其中，第一个是start，第二个参数是count，比如例子的意思就是从10开始，生产5个连续的int，就是10,11,12,13,14<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnSubscribeRange --&gt; start ,end</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/range.c.png" alt=""></p>
<h6 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a><strong>repeat</strong></h6><p>重复发送使用一个Observable，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 2).repeat(4).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>他默认是在一个新线程去运行的，需要注意的是repeat不是一个static方法，他是操作在一个Observable之上的。<br><img src="http://reactivex.io/documentation/operators/images/repeat.c.png" alt=""></p>
<h6 id="timer"><a href="#timer" class="headerlink" title="timer"></a><strong>timer</strong></h6><p>用于延迟多久之后开始某动作，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.timer(2,TimeUnit.SECONDS, Schedulers.newThread()).subscribe(new Action1&lt;Long&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void call(Long aLong) &#123;</div><div class="line">            Log.i(TAG, aLong.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/timer.c.png" alt=""></p>
<h6 id="empty-never-error"><a href="#empty-never-error" class="headerlink" title="empty ,never,error"></a><strong>empty</strong> ,<strong>never</strong>,<strong>error</strong></h6><p>用来处理特殊情况的Observable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable.empty(); //用来发送不发射任何数据的但是正常结束的Observable</div><div class="line">Observable.never();// 不发射数据也不终止</div><div class="line">Observable.error(new Throwable());// 发射一个错误</div></pre></td></tr></table></figure></p>
<p>他的使用就是你需要返回一个Observable对象，但是这个对象又不能为空，又不能去处理事情的时候就可以使用。<br><img src="http://reactivex.io/documentation/operators/images/empty.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/never.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/throw.c.png" alt=""></p>
<h5 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h5><h6 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h6><p>转换对象的时候使用，就是把一个Observable装换为另外一个Observable，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;).map(new Func1&lt;String, Integer&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public Integer call(String s) &#123;</div><div class="line">           return s.hashCode();</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public void call(Integer integer) &#123;</div><div class="line"> </div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>从这个例子我们就可以看出，这里是把一个关于String的Observable变换为了一个关于Integer的Observable，最后让被观察者得到。<br>map适合的范围是1对1的装换，不适合一对多的装换。</p>
<h6 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h6><p>一对多的转换，他的一版使用场景就是，比如去除for循环(map也行)，比如需要把从一个对象去除它包含的List子对象然后迭代等，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个对象A中，包含了一个List&lt;B\&gt; ，现在需要取出B</div></pre></td></tr></table></figure></p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.just(test).flatMap(new Func1&lt;Test, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;String&gt; call(Test test) &#123;</div><div class="line">                return Observable.from(test.list);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s+&quot;---FlatMap&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>使用Map是暂时无法做到这一点的，除非是在call内部使用一个for循环去做。<br>flatMap的图是：<br><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt=""></p>
<h6 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a><strong>concatMap</strong></h6><p>一个输出有序的Observable，他的用户跟flatMap差不多，只是，他是会按照顺序输出，flatMap不一定，这种情况是在你需要返回一个Observable<t>对象的时候，他是通过异步去获取的，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.from(test.list).flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public Observable&lt;String&gt; call(String str) &#123;</div><div class="line">              return Observable.just(str).subscribeOn(Schedulers.from(Executors.newFixedThreadPool(1)));</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(String s) &#123;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></t></p>
<p>使用flatMap的话并不一定能保证顺序。在测试过程发现假如把Schedulers.from(Executors.newFixedThreadPool(1))替换为Schedulers.io()或者是Schedulers.newThread()等是顺序不会变的，目前还不知道为什么，就是使用自定义的线程池的时候会。<br><img src="http://reactivex.io/documentation/operators/images/concatMap.png" alt=""></p>
<h6 id="swichMap"><a href="#swichMap" class="headerlink" title="swichMap"></a><strong>swichMap</strong></h6><p> 同样是跟flatMap很类似，除了有一点，就是在异步环境下，当旧数据订阅没有完成，switchMap取消订阅和停止监视那个数据项产生的的Observable，比如下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.from(test.list).switchMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;String&gt; call(String s) &#123;</div><div class="line">                return Observable.just(s).subscribeOn(Schedulers.newThread());</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>被监视的Observable是否取消决定于他是否已经被观察者得到，假如得到的话观察者是能看到这个值的，但是假如他没有被观察者得到，就会被取消订阅，并且不在被观察。<br>上面那个假如是写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Observable.from(test.list).switchMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public Observable&lt;String&gt; call(String s) &#123;</div><div class="line">           try &#123;</div><div class="line">               Thread.sleep(2000);</div><div class="line">           &#125; catch (InterruptedException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line">           return Observable.just(s).subscribeOn(Schedulers.newThread());</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public void call(String s) &#123;</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>就会得到所有的输出。<br><img src="http://reactivex.io/documentation/operators/images/switchMap.png" alt=""></p>
<h6 id="case"><a href="#case" class="headerlink" title="case"></a><strong>case</strong></h6><p>转换操作符，他是强制制定类型的装换，没有map那么灵活，而且，当不能装换的时候，会爆出ClassCastException，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">Observable.just(&quot;A&quot;).cast(String.class).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void call(String String) &#123;</div><div class="line">        Log.i(TAG,String);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/cast.png" alt=""></p>
<h6 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a><strong>groupBy</strong></h6><p>分组 就是按照一种类型的key分组，例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).groupBy(new Func1&lt;Integer, Integer&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public Integer call(Integer integer) &#123;</div><div class="line">          //制定某种规则，这里是分为了三种</div><div class="line">              return integer % 3;</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(GroupedObservable&lt;Integer, Integer&gt; stringIntegerGroupedObservable) &#123;</div><div class="line">              stringIntegerGroupedObservable.subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">                  @Override</div><div class="line">                  public void call(Integer integer) &#123;</div><div class="line">                      Log.i(TAG, stringIntegerGroupedObservable.getKey() + &quot;====&quot; +integer.toString());</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 1====10</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 2====11</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 0====12</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 1====13</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 2====14</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 0====15</div></pre></td></tr></table></figure></p>
<p>再比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;AB&quot;,&quot;C&quot;,&quot;D&quot;).groupBy(new Func1&lt;String,Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(String s) &#123;</div><div class="line">               return s.contains(&quot;A&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;GroupedObservable&lt;Boolean, String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(GroupedObservable&lt;Boolean, String&gt; stringGroupedObservable) &#123;</div><div class="line">               stringGroupedObservable.subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public void call(String s) &#123;</div><div class="line">                       Log.i(TAG, stringGroupedObservable.getKey() + &quot;====&quot; +s.toString());</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: true====A</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: true====A</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: false====B</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: true====AB</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: false====C</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: false====D</div></pre></td></tr></table></figure></p>
<p>其中stringGroupedObservable.getKey()是获得分组的依据的表示，之后的那个是值。<br><img src="http://reactivex.io/documentation/operators/images/groupBy.c.png" alt=""></p>
<h6 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a><strong>Scan</strong></h6><p>他的作用是连续对数据序列的每一项应用一个func，然后连续发射结果。例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,2).scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Integer call(Integer integer, Integer integer2) &#123;</div><div class="line">               Log.i(TAG, integer +&quot;===&quot;+integer2);</div><div class="line">               return integer+integer2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;Subacriber&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">09-01 21:40:45.112 22400-22400/com.example.user.testproject I/RxJavaTest: 10Subacriber</div><div class="line">09-01 21:40:45.112 22400-22400/com.example.user.testproject I/RxJavaTest: 10===11</div><div class="line">09-01 21:40:45.112 22400-22400/com.example.user.testproject I/RxJavaTest: 21Subacriber</div></pre></td></tr></table></figure></p>
<p>他的第一个值是不参与func2的操作，当然你也可以传递一个init值进入作为默认操作。他的第一个参数是上一次计算的结果传入，第二个参数是被观察的序列值，从2开始，第三个是返回类型，三者是类型一样的。使用一个默认的种子计算的，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 2).scan(&quot;A&quot;, new Func2&lt;String, Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(String s, Integer integer) &#123;</div><div class="line">               Log.i(TAG, s + &quot;==&quot; + integer);</div><div class="line">               return s + integer;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A==10</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A10</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A10==11</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A1011</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.c.png" alt=""></p>
<h6 id="flatMapIterable"><a href="#flatMapIterable" class="headerlink" title="flatMapIterable"></a><strong>flatMapIterable</strong></h6><p>他的作用是处理一些复杂的数据，接受一个Observable之后，返回一个Iterable，然后，这个Iterable会依次的传递给下面一层或者是Observer，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        list.add(&quot;A&quot;);</div><div class="line">        list.add(&quot;E&quot;);</div><div class="line">        list.add(&quot;K&quot;);</div><div class="line">        Observable.from(list).flatMapIterable(new Func1&lt;String, Iterable&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Iterable&lt;Integer&gt; call(String s) &#123;</div><div class="line">                return getIntegers(s);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            private Iterable&lt;Integer&gt; getIntegers(String s) &#123;</div><div class="line">                List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</div><div class="line">                integers.add((int) s.charAt(0)+1);</div><div class="line">                integers.add(s.charAt(0)+2);</div><div class="line">                return integers;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer +&quot;==flatMapIterable&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 66==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 67==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 70==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 71==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 76==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 77==flatMapIterable</div></pre></td></tr></table></figure></p>
<h6 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a><strong>buffer</strong></h6><p>该操作符的作用是先计算一定量的结果，之后再去回调结果给下一个Observable或者是Observer，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;).buffer(2).subscribe(new Action1&lt;List&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(List&lt;String&gt; strings) &#123;</div><div class="line">               Log.i(TAG, strings +&quot;==flatMapIterable&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">09-01 22:10:41.272 24829-24829/com.example.user.testproject I/RxJavaTest: [A, B]==flatMapIterable</div><div class="line">09-01 22:10:41.272 24829-24829/com.example.user.testproject I/RxJavaTest: [C]==flatMapIterable</div></pre></td></tr></table></figure></p>
<p>这个方法是按照顺序不重复，当然他还有很多重载的操作，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffer(int count, int skip) // 一次缓存几个，之后每次跳过几个，按照顺序，重复，每次剔除最前面的</div><div class="line">buffer(long timespan, long timeshift, TimeUnit unit)</div><div class="line">buffer(long timespan, TimeUnit unit)// 每个多久，取出数据</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/Buffer.png" alt=""></p>
<h6 id="window"><a href="#window" class="headerlink" title="window"></a><strong>window</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h5 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h5><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h6><p>符合某种规则的Observable才会向下传递，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.range(100,10).filter(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public Boolean call(Integer integer) &#123;</div><div class="line">           return integer&gt;105;</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public void call(Integer integer) &#123;</div><div class="line"> </div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.c.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.png" alt=""><br>上面的Subscriber只会得到大于105的数值</p>
<h6 id="first"><a href="#first" class="headerlink" title="first"></a><strong>first</strong></h6><p>只发射第一项，或者是满足条件的第一项，两个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.range(100,5).first();// 发射100</div><div class="line">Observable.range(100,5).first(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public Boolean call(Integer integer) &#123;</div><div class="line">        return integer&gt;102;//发射103</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.c.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.png" alt=""></p>
<h6 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a><strong>Debounce</strong></h6><p>当操作太频繁的时候，在第N个节点发射之前会忽略钱N-1个节点，比如我们的Edittext去seach的时候，可能需要过滤前多少秒的操作只是需要后续的操作。简单点来说，就是，他需要的是在某个时间点之后的结果，在这个时间点之前的结果他会忽略不再发送给下一级。例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</div><div class="line">               try &#123;</div><div class="line">                   for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">                       subscriber.onNext(i);</div><div class="line">                       Thread.sleep(100*i);</div><div class="line">                   &#125;</div><div class="line">                   subscriber.onCompleted();</div><div class="line">               &#125; catch (InterruptedException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">                   subscriber.onError(e);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribeOn(Schedulers.newThread())</div><div class="line">               .debounce(500, TimeUnit.MILLISECONDS).subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;OnComplete&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;Throwable&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(Integer integer) &#123;</div><div class="line">               Log.i(TAG, &quot;integer == &quot;+integer.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出就是6.7.8.9.10<br>总结就是debounce操作符就是类似一个控制入口，他是有一个门卡的，门卡一般是时间，在这之前的忽略，之后的可以进入<br>例子是来自<a href="http://blog.csdn.net/job_hesc/article/details/46495281" target="_blank" rel="external"> Android RxJava使用介绍（三） RxJava的操作符</a><br>其中，还有一个throttleWithTimeout操作符，他的底层也是通过调用debounce操作符完成的，作用类似。但是debounce比她在、多了一个功能就是可以通过函数来进行限流操作。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.just(1, 2, 3, 4, 5).debounce(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Integer&gt; call(Integer integer) &#123;</div><div class="line">                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</div><div class="line">                        if (integer % 2 == 0 &amp;&amp; !subscriber.isUnsubscribed()) &#123;</div><div class="line">                            subscriber.onNext(integer);</div><div class="line">                            subscriber.onCompleted();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(Integer integer) &#123;</div><div class="line">                        Log.i(TAG, integer.toString() + &quot;==integer&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>结果输出是2.4.5。5为什么在其中？因为，在debounce操作符中，最后一个Observable，在被调用onComplete之前的时间间隔内被调用，那么他也会被传递到下一级。<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.c.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.f.png" alt=""></p>
<h6 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a><strong>Distinct</strong></h6><p>只允许没有发射过的数据发射，可以定义过滤规则，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.range(1,5).distinct(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public String call(Integer integer) &#123;</div><div class="line">              if(integer&lt;=2) return &quot;1&quot;;// 定义过滤规则</div><div class="line">              return &quot;2&quot;;</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Integer integer) &#123;</div><div class="line">              Log.i(TAG, integer.toString());</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      Observable.just(1,2,3,1,2).distinct().subscribe(new Action1&lt;Integer&gt;() &#123; // 使用默认规则</div><div class="line">          @Override</div><div class="line">          public void call(Integer integer) &#123;</div><div class="line">              Log.i(TAG, integer.toString());</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 1==自定义</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 3==自定义</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 1===系统</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 2===系统</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 3===系统</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.key.png" alt=""></p>
<h6 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a><strong>elementAt</strong></h6><p>某一位置的元素可以发射，需要需要越界的问题，他是从0开始计算的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).elementAt(9).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.png" alt=""></p>
<h6 id="last"><a href="#last" class="headerlink" title="last"></a><strong>last</strong></h6><p>最后一个或者满足条件的最后一个，跟first相反，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,5).last();</div><div class="line">        Observable.range(10,5).last(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(Integer integer) &#123;</div><div class="line">                return integer&gt;13;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString()+&quot;===last&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h6 id="skip"><a href="#skip" class="headerlink" title="skip"></a><strong>skip</strong></h6><p>跳过前N项，从第N+1开始发射，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,20).skip(10);</div></pre></td></tr></table></figure></p>
<p>这个例子是丢弃了10~29中的10~19，保留20~29，还有两个重载的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">skip(long,TimeUnit));// 跳过前long时间的Observable，发射之后的</div><div class="line">skip(long,TimeUnit,Scheduler));//可以定义调度器</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.png" alt=""><br>结果是14，两个都是<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png" alt=""></p>
<h6 id="skipLast"><a href="#skipLast" class="headerlink" title="skipLast"></a><strong>skipLast</strong></h6><p>不发射后n项数据，跟skip相反，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(1,10).skipLast(3).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Integer integer) &#123;</div><div class="line">              Log.i(TAG, integer.toString() + &quot;==skip&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：1,2,3,4,5,6,7<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.c.png" alt=""></p>
<h6 id="take"><a href="#take" class="headerlink" title="take"></a><strong>take</strong></h6><p>只取前n项数据，例如有10项数据，那么take(4)，就是只是圈前4项数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).take(5).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString() + &quot;==take&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：10,11，12,13,14<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.c.png" alt=""></p>
<h6 id="taskLast"><a href="#taskLast" class="headerlink" title="taskLast"></a><strong>taskLast</strong></h6><p>只发射最后n项数据，比如有10项数据，taskLast(3)，则是只发射最后3项数据，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(9,5).takeLast(2).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void call(Integer integer) &#123;</div><div class="line">            Log.i(TAG, integer.toString() + &quot;==integer&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：12和13<br>需要注意的是他是一个线程同步的，他可能造成Observable发射延迟，因为他只有过滤掉前面的数据才会轮到后面，然后后面的数据才会发射。<br>重构的方法有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">takeLast(final int count)  //发射后面n个数据，n大于数据全部的时候则发射全部n小于0报异常</div><div class="line">takeLast(int count, long time, TimeUnit unit)// 发射最后给定时间的n个数据</div><div class="line">takeLast(int count, long time, TimeUnit unit, Scheduler scheduler)</div><div class="line">takeLast(long time, TimeUnit unit, Scheduler scheduler)//发射最后给定时间的全部数据，可以指定调度器</div><div class="line">takeLast(long time, TimeUnit unit)</div></pre></td></tr></table></figure></p>
<p>同时，他还有一个变形，<em>takeLastBuffer*</em>，takeLast是一个一个数据源返回，但是takeLastBuffer是以List的形式返回，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(20,10).takeLastBuffer(5).subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(List&lt;Integer&gt; integers) &#123;</div><div class="line">              Log.i(TAG, integers.toString() + &quot;==integer&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.c.png" alt=""></p>
<h6 id="ignoreElements"><a href="#ignoreElements" class="headerlink" title="ignoreElements"></a><strong>ignoreElements</strong></h6><p>忽略所有的元素，只是发射结束事件或者是错误时间，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).ignoreElements().subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot;);</div><div class="line">           &#125;</div><div class="line">           @Override</div><div class="line">           public void onNext(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString() + &quot;==ignoreElements&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ignoreElements.c.png" alt=""></p>
<h6 id="last-1"><a href="#last-1" class="headerlink" title="last"></a><strong>last</strong></h6><p>只发射最后的一项数据，忽略前面n项数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).last().subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString() + &quot;==last&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：19<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.c.png" alt=""><br>还有一个last(Func1)的重载函数，他可以规定那个才是last，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).last(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString() + &quot;==last&quot;);</div><div class="line">                return integer == 14;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString() + &quot;==last func&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>在subscribe里面输出的就是14而不是19，还有一个相似函数是:lastOrDefault(T)，他会在Observable没有发射任何数据的时候发射默认值T。<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png" alt=""></p>
<h6 id="sample操作符"><a href="#sample操作符" class="headerlink" title="sample操作符"></a><strong>sample</strong>操作符</h6><p>他是在某一段时间内采集过去发射的旧数据再次发射，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.interval(1,TimeUnit.SECONDS).sample(2,TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Long aLong) &#123;</div><div class="line">              Log.i(TAG, aLong.toString() + &quot;==sample &quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>interval创造一个Observable之后每个1s发射一个新数据，然后sample会在2s重复的去采集已经发射的旧数据再次发射，输出的结果是:0,2,4,6…<br>它默认kaiq新线程，我们也可指线程给sample运行<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.c.png" alt=""></p>
<p>使用</p>
<h5 id="结合操作符"><a href="#结合操作符" class="headerlink" title="结合操作符"></a>结合操作符</h5><p>组合操作符的作用是可以结合多个Observable进行操作。</p>
<h6 id="CombineLatest-操作符"><a href="#CombineLatest-操作符" class="headerlink" title="CombineLatest 操作符"></a><strong>CombineLatest</strong> 操作符</h6><p>他可以组合两个Observable，进行一定的操作之后，再次发射下去，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.combineLatest(Observable.range(5,2), Observable.range(10, 4), new Func2&lt;Integer, Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer, Integer integer2) &#123;</div><div class="line">               return integer+&quot;==&quot;+integer2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s + &quot;=combineLatest&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==10=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==11=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==12=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==13=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==14=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==15=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==16=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==17=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==18=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==19=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==20=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==21=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==22=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==23=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==24=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==25=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==26=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==27=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==28=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==29=combineLatest</div></pre></td></tr></table></figure></p>
<p>它继续发射的前提是：其中的一个Observable还有数据没有发射，那么，他讲两个Observable目前最新发射的数据组合在一起，比如上面，第一个Observable最新的数据是6，然后第二个的依次在变，然后再把他们组合在一起。<br>重载方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">combineLatest(List&lt;? extends Observable&lt;? extends T&gt;&gt; sources, FuncN&lt;? extends R&gt; combineFunction)</div><div class="line">或者是：</div><div class="line">combineLatest(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources, FuncN&lt;? extends R&gt; combineFunction)</div></pre></td></tr></table></figure></p>
<p>他们都是输入一堆的List<observable<t>&gt;类型的数据或者是Iterable数据，然后通过可变参数进行处理，适合需要多个Observable进行拼接，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">List&lt;Observable&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">       list.add(A.range(10, 1));</div><div class="line">       list.add(A.range(10, 1));</div><div class="line">       list.add(A.range(10, 1));</div><div class="line">       Observable.combineLatest(list, new FuncN&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Object call(Object... args) &#123;</div><div class="line">               for (Object obj : args) &#123;</div><div class="line">                   Log.i(TAG, obj.toString());</div><div class="line">               &#125;</div><div class="line">               return args;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Object o) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></observable<t></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.c.png" alt=""></p>
<h6 id="join组合操作符"><a href="#join组合操作符" class="headerlink" title="join组合操作符"></a><strong>join</strong>组合操作符</h6><p>他的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final &lt;TRight, TLeftDuration, TRightDuration, R&gt; Observable&lt;R&gt; join(Observable&lt;TRight&gt; right, Func1&lt;T, Observable&lt;TLeftDuration&gt;&gt; leftDurationSelector,</div><div class="line">            Func1&lt;TRight, Observable&lt;TRightDuration&gt;&gt; rightDurationSelector,</div><div class="line">            Func2&lt;T, TRight, R&gt; resultSelector)</div></pre></td></tr></table></figure></p>
<p>例子调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; left =</div><div class="line">                Observable.interval(100, TimeUnit.MILLISECONDS)</div><div class="line">                        .map(new Func1&lt;Long, String&gt;() &#123;</div><div class="line">                            @Override</div><div class="line">                            public String call(Long aLong) &#123;</div><div class="line">                                return &quot;L&quot; + aLong;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">        Observable&lt;String&gt; right =</div><div class="line">                Observable.interval(200, TimeUnit.MILLISECONDS)</div><div class="line">                        .map(new Func1&lt;Long, String&gt;() &#123;</div><div class="line">                            @Override</div><div class="line">                            public String call(Long aLong) &#123;</div><div class="line">                                return &quot;R&quot; + aLong;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">        left.join(right, new Func1&lt;String, Observable&lt;Integer&gt;&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Observable&lt;Integer&gt; call(String s) &#123;</div><div class="line">                        Log.i(TAG, s + &quot;==&quot;);</div><div class="line">                        return Observable.never();</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Observable&lt;Long&gt; call(String s) &#123;</div><div class="line">                        Log.i(TAG, s + &quot;=====&quot;);</div><div class="line">                        return Observable.timer(0, TimeUnit.MILLISECONDS);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                , new Func2&lt;String, String, String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public String call(String s, String s2) &#123;</div><div class="line">                        return s + &quot;-&quot; + s2;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .take(10)</div><div class="line">                .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(String s) &#123;</div><div class="line">                        Log.i(TAG, s);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>例子来源：<a href="http://blog.chengyunfeng.com/?p=980&amp;utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">RxJava 教程第四部分：并发 之意外情况处理</a><br>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">L0==</div><div class="line">L1==</div><div class="line">R0=====</div><div class="line">L1-R0</div><div class="line">L0-R0</div><div class="line">L2==</div><div class="line">L3==</div><div class="line"> R1=====</div><div class="line"> L1-R1</div><div class="line">L0-R1</div><div class="line">L3-R1</div><div class="line">L2-R1</div><div class="line">L4==</div><div class="line">R2=====</div><div class="line">L4-R2</div><div class="line">L1-R2</div><div class="line">L0-R2</div><div class="line"> L3-R2</div></pre></td></tr></table></figure></p>
<p>可以看到，在right join如left之后，她会结合每一次left的发射的Observable，然后再次发射，但是他的前提是left窗口还有数据在发射。假如left窗口没有数据了，那么right窗口也就不会再去跟left窗口接口再去发射了，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).join(Observable.range(10, 2), new Func1&lt;Integer, Observable&lt;Object&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Object&gt; call(Integer integer) &#123;</div><div class="line">                return Observable.just(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Func1&lt;Integer, Observable&lt;Object&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Object&gt; call(Integer integer) &#123;</div><div class="line">                return Observable.never();</div><div class="line">            &#125;</div><div class="line">        &#125;, new Func2&lt;Integer, Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String call(Integer integer, Integer integer2) &#123;</div><div class="line">                return integer + &quot;-&quot; + integer2;</div><div class="line">            &#125;</div><div class="line">        &#125;).take(10).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s + &quot;join&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>将不会有输出。<br>图：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png" alt=""></p>
<h6 id="merge-组合操作符"><a href="#merge-组合操作符" class="headerlink" title="merge 组合操作符"></a><strong>merge</strong> 组合操作符</h6><p>用于合并多个Observable，他们需要同类型，按照前到后的顺历依次发射所有的Observable例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.merge(Observable.range(10,2),Observable.range(20,3)).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;merge&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 10merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 11merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 20merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 21merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 22merge</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png" alt=""></p>
<h6 id="zip-组合操作符"><a href="#zip-组合操作符" class="headerlink" title="zip 组合操作符"></a><strong>zip</strong> 组合操作符</h6><p>用于多两个Observable进行再次操作之后再次发射，他是有顺序的，他会按照顺序去结合多个Observable之间的数据，按照最短的数据为zip的func2的调用次数，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.zip(Observable.range(10, 10), Observable.range(5, 2), new Func2&lt;Integer, Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer, Integer integer2) &#123;</div><div class="line">               return integer+&quot;-&quot;+integer2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG,s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10-19 15:57:57.482 11123-11123/com.example.user.testproject I/RxJavaTest: 10-5</div><div class="line">10-19 15:57:57.482 11123-11123/com.example.user.testproject I/RxJavaTest: 11-6</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/zip.o.png" alt=""></p>
<h6 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a><strong>zipWith</strong></h6><p>跟zip类型，但是他是非静态的，需要在另外一个Observable操作之上,他接受两个参数，一种是一个Observable和Func2，另外一个是多个组合， Iterable和Func2例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,2).zipWith(Observable.range(10,1),new Func2&lt;Integer,Integer,String&gt;()&#123;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public String call(Integer o, Integer o2) &#123;</div><div class="line">               return o+&quot;=&quot;+o2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG,s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/zip.i.png" alt=""></p>
<h6 id="switchOnNext"><a href="#switchOnNext" class="headerlink" title="switchOnNext"></a><strong>switchOnNext</strong></h6><p>将一个发射多个Observable对象装换为一个Observable发射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.switchOnNext(Observable.just(Observable.range(1,1),Observable.range(2,1))).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;switchOnNext&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10-19 16:13:26.296 24641-24641/? I/RxJavaTest: 1switchOnNext</div><div class="line">10-19 16:13:26.296 24641-24641/? I/RxJavaTest: 2switchOnNext</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/switch.c.png" alt=""></p>
<h6 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a><strong>startWith</strong></h6><p>在源Observable之前插入一个或者是多个数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(5,2).startWith(6).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;switchOnNext&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10-19 16:16:10.690 27055-27055/? I/RxJavaTest: 6switchOnNext</div><div class="line">10-19 16:16:10.690 27055-27055/? I/RxJavaTest: 5switchOnNext</div><div class="line">10-19 16:16:10.690 27055-27055/? I/RxJavaTest: 6switchOnNext</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/startWith.png" alt=""></p>
<h5 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h5><p>错误处理操作符主要是在Observable的onError中拦截，做一些事情。</p>
<h6 id="catch操作符"><a href="#catch操作符" class="headerlink" title="catch操作符"></a>catch操作符</h6><p>1  <strong>onErrorReturn</strong> 让Observable遇到错误时候发生一个特殊的数据并且正常终止，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.just(1, 2, 3, 4, 5).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if (integer == 4) &#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;hahaha&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer + &quot;str&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;).onErrorReturn(new Func1&lt;Throwable, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Throwable throwable) &#123;</div><div class="line">               Log.i(TAG, throwable.getMessage());</div><div class="line">               return &quot;Bingo&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;Result == &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == 1str</div><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == 2str</div><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == 3str</div><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: hahaha</div><div class="line">10-26 13:25:46.633 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == Bingo</div></pre></td></tr></table></figure></p>
<p>说明：onErrorReturn操作符他会拦截错误，然后在拦截错误之后，不再继续发射源Observable的数据，同时，他将在Func1中返回一个对应的可被观测的数据传递到onNext中，然后调用了onComplete方法完成这一次的Observable过程。</p>
<p>2  <strong>onErrorResumeNext</strong> 让Observable遇到错误时开始发射第二个Observable数据序列，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.just(1, 2, 3, 4, 5).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if (integer == 4) &#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;hahaha&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer + &quot;str&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"> observable.onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;? extends String&gt; call(Throwable throwable) &#123;</div><div class="line">               return Observable.just(&quot;Bingo&quot;,&quot;Hello&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;onErrorResumeNext == &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == 1str</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == 2str</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == 3str</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == Bingo</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == Hello</div></pre></td></tr></table></figure></p>
<p>可以看到他是终止了继续发射，但是他可以补充发射，就是在遇到错误的时候，可以在源Observable基础上面继续发射多个Observable直到结束。<br>他的重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; onErrorResumeNext(final Observable&lt;? extends T&gt; resumeSequence)</div></pre></td></tr></table></figure></p>
<p>使用也是类似，他也是可以在遇到错误之后发射多个Observable。</p>
<p>3  <strong>onExceptionResumeNext</strong> 让Observable遇到错误时发射继续发射后面的数据项，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.just(1, 2, 3, 4, 5).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if (integer == 4) &#123;</div><div class="line">                   throw new Error(&quot;hahaha&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer + &quot;str&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"> observable.onExceptionResumeNext(Observable.just(&quot;A&quot;, &quot;B&quot;)).subscribe(new Observer&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot;+e.getMessage());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;onNext&quot;+s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-26 13:49:21.803 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext1str</div><div class="line">10-26 13:49:21.803 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext2str</div><div class="line">10-26 13:49:21.803 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext3str</div><div class="line">10-26 13:49:21.813 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorhahaha</div></pre></td></tr></table></figure></p>
<p>加入不是抛出Error，而是Exception的子类的时候，则结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext1str</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext2str</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext3str</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNextA</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNextB</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onCompleted</div></pre></td></tr></table></figure></p>
<p>说明onExceptionResumeNext操作符是在上级源Observable出现的是Exception的子类的时候调用他自己的Observable继续发射下去，同时是不回再去发射源Observable的数据。但是假如上级源Observable出现的不是Exception的子类的时候，那么他会直接调用onError方法结束发射。<br>对应的图：<br>onErrorReturn：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorReturn.png" alt=""><br>onErrorResumeNext：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorResumeNext.png" alt=""><br>onExceptionResumeNext：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onExceptionResumeNextViaObservable.png" alt=""></p>
<h6 id="retry操作符"><a href="#retry操作符" class="headerlink" title="retry操作符"></a>retry操作符</h6><p>retry操作符不会把错误传递到Observer的onError当中去。他可以不停的retry，尝试能够让源Observable正常发射结束。<br>1 <strong>retry</strong> 操作符，他会在源Observable在发生error的时候不断的重新去调用源数据，重头开始发射，存在了数据可能重复的结果，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if(integer == 11)&#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer.toString() + &quot;retry&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.retry().subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是不断的打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10retry</div></pre></td></tr></table></figure></p>
<p>重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; retry(final long count)</div></pre></td></tr></table></figure></p>
<p>他可以设置重试次数，超出重试次数之后任然发生错误，那么他将会调用onError方法，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if(integer == 11)&#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer.toString() + &quot;retry&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.retry(2).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Throwable throwable) &#123;</div><div class="line">               Log.i(TAG, throwable.getMessage());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-26 14:22:50.137 4099-4099/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:22:50.138 4099-4099/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:22:50.138 4099-4099/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:22:50.138 4099-4099/com.example.user.testproject I/RxJavaTest: exception</div></pre></td></tr></table></figure></p>
<p>重载函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">retry(Func2&lt;Integer, Throwable, Boolean&gt; predicate)</div></pre></td></tr></table></figure></p>
<p>他可以设定某种界限，在不超出某个条件之下不断的重试，或者说只要是返回了true都会重试，反之停止，停止之后还是发生了错误，就会调用onError方法，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if(integer == 11)&#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer.toString() + &quot;retry&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(Integer integer, Throwable throwable) &#123;</div><div class="line">               return integer&lt;3;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Throwable throwable) &#123;</div><div class="line">               Log.i(TAG, throwable.getMessage());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>他的意思是，在重试次数少于3的时候就会重试，否则就不会，输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-26 14:28:34.882 8577-8577/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:28:34.883 8577-8577/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:28:34.883 8577-8577/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:28:34.883 8577-8577/com.example.user.testproject I/RxJavaTest: exception</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retry.C.png" alt=""></p>
<ol>
<li><strong>retryWhen</strong> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String call(Integer integer) &#123;</div><div class="line">                if(integer == 11)&#123;</div><div class="line">                    throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">                &#125;</div><div class="line">                return integer.toString() + &quot;retry&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        observable.retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; observable) &#123;</div><div class="line">               return observable.zipWith(Observable.range(1, 3), new Func2&lt;Throwable, Integer, Object&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public Object call(Throwable throwable, Integer integer) &#123;</div><div class="line">                       return &quot;123&quot;;</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10-26 15:06:44.358 26227-26227/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 15:06:44.359 26227-26227/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 15:06:44.359 26227-26227/com.example.user.testproject I/RxJavaTest: 10retry</div></pre></td></tr></table></figure></p>
<p>说明:这里使用了zipWith限制了retryWhen的次数，当超出了三次之后，zipWith回隐式的调用onComplete方法，所以这里的Observer的onError方法并不会被调用。<br> 例子来源：<a href="http://www.jianshu.com/p/023a5f60e6d0" target="_blank" rel="external">【译】对RxJava中.repeatWhen()和.retryWhen()操作符的思考</a><br>关于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; retryWhen(final Func1&lt;? super Observable&lt;? extends Throwable&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler)</div></pre></td></tr></table></figure></p>
<p>中的notificationHandler的Observable返回说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">– 如果返回的 Observable 发射了一个数据，retryWhen 将会执行重试操作</div><div class="line">– 如果返回的 Observable 发射了一个错误信息，retryWhen 将会发射一个错误并不会重试</div><div class="line">– 如果返回的 Observable 正常结束了，retryWhen 也正常结束。</div></pre></td></tr></table></figure></p>
<p>出处：<a href="http://blog.chengyunfeng.com/?p=970" target="_blank" rel="external">RxJava 教程第三部分：驯服数据流之 高级错误处理</a><br>也就是说，其实retryWhen的Func1返回的Observable的值并不重要，是他的类型重要，他只是判断是否可以继续执行retryWhen，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; source = Observable.create(o -&gt; &#123;</div><div class="line">    o.onNext(1);</div><div class="line">    o.onNext(2);</div><div class="line">    o.onError(new Exception(&quot;Failed&quot;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">source.retryWhen((o) -&gt; o</div><div class="line">        .take(2)</div><div class="line">        .delay(100, TimeUnit.MILLISECONDS))</div><div class="line">    .timeInterval()</div><div class="line">    .subscribe(</div><div class="line">        System.out::println,</div><div class="line">        System.out::println);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TimeInterval [intervalInMilliseconds=21, value=1]</div><div class="line">TimeInterval [intervalInMilliseconds=0, value=2]</div><div class="line">TimeInterval [intervalInMilliseconds=104, value=1]</div><div class="line">TimeInterval [intervalInMilliseconds=0, value=2]</div><div class="line">TimeInterval [intervalInMilliseconds=103, value=1]</div><div class="line">TimeInterval [intervalInMilliseconds=0, value=2]</div></pre></td></tr></table></figure></p>
<p>出处：<a href="http://blog.chengyunfeng.com/?p=970" target="_blank" rel="external">RxJava 教程第三部分：驯服数据流之 高级错误处理</a><br>他还有一个重载的操作符可以指定调度器Scheduler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; retryWhen(final Func1&lt;? super Observable&lt;? extends Throwable&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler, Scheduler scheduler)</div></pre></td></tr></table></figure></p>
<h5 id="辅助操作符"><a href="#辅助操作符" class="headerlink" title="辅助操作符"></a>辅助操作符</h5><p>RxJava提供很多的辅助操作符，帮助我们更好的堆Observable进行更加方便的操作。</p>
<h6 id="meterailize-Dematerialize-操作符"><a href="#meterailize-Dematerialize-操作符" class="headerlink" title="meterailize/Dematerialize 操作符"></a><strong>meterailize/Dematerialize</strong> 操作符</h6><p>meterailize操作符被一个合法有限的Observable调用的时候，如果Observable调用Observer的onNext次数为0或者多次，omComplete次数为1次，或者onError1次。meterailize会将不管是onNext还是onComplete还是onError包装成为Observable发射，而Dematerialize的作用则是相反。meterailize使用的时候他会包装Observable的数据源为一个Notification<t>类型再去传递，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,3).map(new Func1&lt;Integer, Notification&lt;Integer&gt;&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public Notification&lt;Integer&gt; call(Integer integer) &#123;</div><div class="line">             return Notification.createOnNext(integer);</div><div class="line">         &#125;</div><div class="line">     &#125;).materialize().subscribe(new Observer&lt;Notification&lt;Notification&lt;Integer&gt;&gt;&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public void onCompleted() &#123;</div><div class="line">             Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">         &#125;</div><div class="line"> </div><div class="line">         @Override</div><div class="line">         public void onError(Throwable e) &#123;</div><div class="line">             Log.i(TAG, &quot;onError&quot;+e.getMessage());</div><div class="line">         &#125;</div><div class="line"> </div><div class="line">         @Override</div><div class="line">         public void onNext(Notification&lt;Notification&lt;Integer&gt;&gt; notification) &#123;</div><div class="line">             Log.i(TAG, &quot;materialize&quot;+notification);</div><div class="line">         &#125;</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></t></p>
<p>输出就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-27 16:35:43.962 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@26788166 OnNext [rx.Notification@133c40b8 OnNext 10]]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@26788167 OnNext [rx.Notification@133c40b9 OnNext 11]]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@26788168 OnNext [rx.Notification@133c40ba OnNext 12]]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@df4db0e OnCompleted]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>可以看到他是多了一个omCompleted事件的，但是这个传递到onNexu的时候他的值是为null的，所以使用的时候注意。<br>假如是使用Dematerialize操作符，他是把materialize数据源包装的Notification<t>还原回去，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 3).map(new Func1&lt;Integer, Notification&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Notification&lt;Integer&gt; call(Integer integer) &#123;</div><div class="line">                return Notification.createOnNext(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;).dematerialize().subscribe(new Subscriber&lt;Object&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(Object notification) &#123;</div><div class="line">                Log.i(TAG, &quot;dematerialize = &quot; + notification);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></t></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-27 16:42:13.563 10276-10276/? I/RxJavaTest: dematerialize = 10</div><div class="line">10-27 16:42:13.564 10276-10276/? I/RxJavaTest: dematerialize = 11</div><div class="line">10-27 16:42:13.564 10276-10276/? I/RxJavaTest: dematerialize = 12</div><div class="line">10-27 16:42:13.564 10276-10276/? I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>还把最后一个空的过滤了。<br>图片：<br><img src="http://reactivex.io/documentation/operators/images/materialize.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/dematerialize.c.png" alt=""></p>
<h6 id="delay-操作符"><a href="#delay-操作符" class="headerlink" title="delay 操作符"></a><strong>delay</strong> 操作符</h6><p>延迟发射Observable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; delay(long delay, TimeUnit unit)</div></pre></td></tr></table></figure></p>
<p>该方法会延时整一个observable，但是延时结束之后会立马开始发射，之后的数据将不会再延时(同时，以下的其他操作符也是基于这个observable的)例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               Log.i(TAG, &quot;发射&quot;);</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.delay(2, TimeUnit.SECONDS).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;delay= &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-30 16:12:58.535 3044-3044/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-30 16:13:00.537 3044-3070/com.example.user.testproject I/RxJavaTest: delay= A</div><div class="line">10-30 16:13:00.538 3044-3070/com.example.user.testproject I/RxJavaTest: delay= B</div><div class="line">10-30 16:13:00.538 3044-3070/com.example.user.testproject I/RxJavaTest: delay= C</div><div class="line">10-30 16:13:00.538 3044-3070/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>需要注意的是：<br>当第一个发射的就是onError的时候，该延时将不会起效，立马就会发射给Observer，但是假如是发射onComplete的时候还是会延时的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; Observable&lt;T&gt; delay(Func1&lt;? super T, ? extends Observable&lt;U&gt;&gt; itemDelay)</div></pre></td></tr></table></figure>
<p>他可以给给一个Observable给定一个延时，当Func1返回的Observable发射的时候，源数据对应的数据就会发射，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">observable.delay(2, TimeUnit.SECONDS);</div><div class="line">        observable.delay(new Func1&lt;String, Observable&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Integer&gt; call(String s) &#123;</div><div class="line">                if (&quot;A&quot;.equals(s)) &#123;</div><div class="line">                    return Observable.just(1)</div><div class="line">                            .delay(1, TimeUnit.SECONDS);</div><div class="line">                &#125;else &#123;</div><div class="line">                    return Observable.just(1)</div><div class="line">                            .delay(2, TimeUnit.SECONDS);</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;delay= &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>结果“<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-30 16:31:12.929  发射</div><div class="line">10-30 16:31:13.955 delay= A</div><div class="line">10-30 16:31:14.956  delay= B</div><div class="line">10-30 16:31:14.958  delay= C</div><div class="line">10-30 16:31:14.959 onCompleted</div></pre></td></tr></table></figure></p>
<p>这里，A是延时了1s发射，但是其他的数据是延时了约2s发射。注意的是他不是有叠加的效果，不会是让上一个Observable发射了之后再去延时下一个。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/delay.o.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/delay.oo.png" alt=""></p>
<h6 id="delaySubscription-操作符"><a href="#delaySubscription-操作符" class="headerlink" title="delaySubscription 操作符"></a><strong>delaySubscription</strong> 操作符</h6><p>他是延迟Observable中OnSubscribe调用call的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; Observable&lt;T&gt; delaySubscription(Func0&lt;? extends Observable&lt;U&gt;&gt; subscriptionDelay)</div></pre></td></tr></table></figure></p>
<p>他根据Func0返回的Observable延迟Observable和Observer之间关联，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">observable.delaySubscription(new Func0&lt;Observable&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;String&gt; call() &#123;</div><div class="line">               Log.i(TAG, &quot;延时订阅开始&quot; );</div><div class="line">               return Observable.just(&quot;A&quot;).delay(2,TimeUnit.SECONDS);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;delaySubscription = &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-30 16:42:28.510 28979-28979/com.example.user.testproject I/RxJavaTest: 延时订阅开始</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: delaySubscription = A</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: delaySubscription = B</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: delaySubscription = C</div></pre></td></tr></table></figure></p>
<p>可以看到延时开始后之后是经过了约2s的时间之后才发生了订阅的关系。<br>重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final Observable&lt;T&gt; delaySubscription(long delay, TimeUnit unit)</div></pre></td></tr></table></figure></p>
<p>该函数的作用也是类似的。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/delaySubscription.o.png" alt=""></p>
<h6 id="do系列操作符"><a href="#do系列操作符" class="headerlink" title="do系列操作符"></a><strong>do</strong>系列操作符</h6><ol>
<li><strong>doOnEach</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnEach(final Action1&lt;Notification&lt;? super T&gt;&gt; onNotification)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>他提供一个Action1的谓词，用于在Observable发射的时候同时也被转换成一个Notification，该Notification中携带了被发射的value，相当于可以多个Observer被调用，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnEach(new Action1&lt;Notification&lt;? super String&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Notification&lt;? super String&gt; notification) &#123;</div><div class="line">              Log.i(TAG, &quot;notification = &quot; + notification.getValue());</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(String s) &#123;</div><div class="line">              Log.i(TAG, &quot;doOnEach = &quot; + s);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = A</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: doOnEach = A</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = B</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: doOnEach = B</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = C</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: doOnEach = C</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = null</div></pre></td></tr></table></figure></p>
<p>其中最后一个是null代表的onComplete函数被调用。<br>重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnEach(Observer&lt;? super T&gt; observer)</div></pre></td></tr></table></figure></p>
<p>他的作用也是类似的，只不过doOnEach参数中的observer的onNext，onComplete,onError也是同样会被调用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">observable.doOnEach(new Observer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot; );</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError = &quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;doOnEach = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: doOnEach = A</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: doOnEach = B</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: doOnEach = C</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/doOnEach.png" alt=""></p>
<ol>
<li><strong>doOnNext</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>他的作用只是会回调被发射源数据的onNext函数而不是全部，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnNext(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;doOnNext = &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: doOnNext = A</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: doOnNext = B</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: doOnNext = C</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: subscribe = C</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/doOnNext.png" alt=""></p>
<ol>
<li><strong>doOnSubscribe</strong>操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnSubscribe(final Action0 subscribe)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>操作符注册一个动作，当观察者订阅它生成的Observable它就会被调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnSubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnSubscribe被调用&quot; );</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: doOnSubscribe被调用</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: subscribe = C</div></pre></td></tr></table></figure></p>
<p>适合做一些在发射数据之前的操作。图：<br><img src="http://reactivex.io/documentation/operators/images/doOnSubscribe.png" alt=""></p>
<ol>
<li><strong>doOnUnsubscribe</strong>操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnUnsubscribe(final Action0 unsubscribe)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当观察者取消订阅它生成的Observable它就会被调用，比如调用了onComplete函数或者是Observer和Observa之间取消了关联的时候被调用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnUnsubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnUnsubscribe&quot; );</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: doOnUnsubscribe</div></pre></td></tr></table></figure></p>
<p>适合做一些收尾的工作，图：<br><img src="http://reactivex.io/documentation/operators/images/doOnUnsubscribe.png" alt=""></p>
<ol>
<li><strong>doOnCompleted</strong>和<strong>doOnError</strong>操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnCompleted(final Action0 onCompleted)</div><div class="line"> Observable&lt;T&gt; doOnError(final Action1&lt;Throwable&gt; onError)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>会在Observa调用对应的函数之前被调用。注意是之前被调用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">observable.doOnCompleted(new Action0() &#123;</div><div class="line">          @Override</div><div class="line">          public void call() &#123;</div><div class="line">              Log.i(TAG, &quot;doOnCompleted &quot; );</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(String s) &#123;</div><div class="line">              Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">          &#125;</div><div class="line">      &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Throwable throwable) &#123;</div><div class="line">              Log.i(TAG, &quot;throwable &quot; + throwable.getMessage());</div><div class="line">          &#125;</div><div class="line">      &#125;, new Action0() &#123;</div><div class="line">          @Override</div><div class="line">          public void call() &#123;</div><div class="line">              Log.i(TAG, &quot;Completed &quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>正常结束的时候结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: doOnCompleted</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: Completed</div></pre></td></tr></table></figure></p>
<p>把observable最后调用改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                Log.i(TAG, &quot;发射&quot;);</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">//                subscriber.onCompleted();</div><div class="line">                subscriber.onError(new IllegalArgumentException(&quot;error&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">  observable.doOnError(new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, &quot;doOnError = &quot; + throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, &quot;throwable &quot; + throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;Completed &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: doOnError = error</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: throwable error</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/doOnCompleted.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/doOnError.png" alt=""></p>
<ol>
<li><strong>doOnTerminate</strong>操作符<br>在Observable发射终止之前调用，无论是正常还是错误的结束，就是相当于doOnCompleted和doOnError两个的结合体<br>例子就不写了，图：<br><img src="http://reactivex.io/documentation/operators/images/doOnTerminate.png" alt=""></li>
<li><p><strong>doAfterTerminate</strong>操作符<br>在Observable终止之后会被调用，也就是在操作符doOnTerminate之后被调用，在doOnUnsubscribe之后被调用<br>图：<br><img src="http://reactivex.io/documentation/operators/images/doAfterTerminate.png" alt=""></p>
</li>
<li><p><strong>finallyDo</strong>操作符<br>该操作符已经被废弃，但是他的作用是当它产生的Observable终止之后会被调用，无论是正常还是异常终止。会在doOnUnsubscribe操作调用之后调用，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">observable.finallyDo(new Action0() &#123;</div><div class="line">           @Override</div><div class="line">           public void call() &#123;</div><div class="line">               Log.i(TAG, &quot;finallyDo &quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).doOnUnsubscribe(new Action0() &#123;</div><div class="line">           @Override</div><div class="line">           public void call() &#123;</div><div class="line">               Log.i(TAG, &quot;doOnUnsubscribe &quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10-31 15:58:56.166 26661-26661/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:58:56.166 26661-26661/com.example.user.testproject I/RxJavaTest: doOnUnsubscribe</div><div class="line">10-31 15:58:56.166 26661-26661/com.example.user.testproject I/RxJavaTest: finallyDo</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/finallyDo.png" alt=""></p>
<h6 id="serialize操作符"><a href="#serialize操作符" class="headerlink" title="serialize操作符"></a><strong>serialize</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; serialize()</div></pre></td></tr></table></figure>
<p>他的作用主要是维持保证Observable能够正常的结束调用。比如，由于我们的Observable发射数据的时候可能是异步的，那么他们就存在着一种这样子的关系：我前面的数据正常调用onNext函数，然后在某一个异步中调用onComplete函数需要正常结束掉这个Observable，但是还有一些没有完成的异步任务，他们完成之后还会调用onNext函数，但是这回导致Observable的调用不正确，我们需要维持这个Observable正常结束，就可以使用serialize。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        ob.doOnUnsubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnUnsubscribe&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;s&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>这时候的输出是正常的，是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: A</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: B</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: C</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: onCompleted</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: doOnUnsubscribe</div></pre></td></tr></table></figure></p>
<p>这是正常的原因是Observer接受到onComplete的时候结束掉了订阅的关系，但是当我们使用<strong>unsafeSubscribe</strong>操作符，该操作符不会使得Observer主动结束订阅关系的时候去订阅Observable的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ob.doOnUnsubscribe(new Action0() &#123;</div><div class="line">           @Override</div><div class="line">           public void call() &#123;</div><div class="line">               Log.i(TAG, &quot;doOnUnsubscribe&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).unsafeSubscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;s&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: C</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: onCompleted</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: D</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>可以看到他是没有正常结束的，应该是发射了C之后就结束的，同时也没有调用unsafeSubscribe函数，这时候我们需要维持正常，就可以使用serialize谓词，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ob.doOnUnsubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnUnsubscribe&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;).serialize().subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG,s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: C</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: onCompleted</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: doOnUnsubscribe</div></pre></td></tr></table></figure></p>
<p>这时候看到的是正常结束了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/serialize.c.png" alt=""></p>
<h6 id="ObserveOn操作符"><a href="#ObserveOn操作符" class="headerlink" title="ObserveOn操作符"></a><strong>ObserveOn</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler)</div><div class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler, int bufferSize)</div><div class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError)</div></pre></td></tr></table></figure>
<p>该操作符用于指定Observer在那个调度器上面去观察Observable，也就是Observable发射数据之后，在Observer中处理时候的线程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Log.i(TAG, Thread.currentThread().getName());</div><div class="line">        Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                Log.i(TAG, &quot;Observable&quot;+Thread.currentThread().getName());</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.observeOn(Schedulers.newThread()).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">                Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;, new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;Complete&quot;);</div><div class="line">                Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">11-01 14:30:00.235 882-882/com.example.user.testproject I/RxJavaTest: main</div><div class="line">11-01 14:30:00.263 882-882/com.example.user.testproject I/RxJavaTest: Observablemain</div><div class="line">11-01 14:30:00.264 882-910/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: C</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Complete</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div></pre></td></tr></table></figure></p>
<p>可以看到Observer处理的线程就是我们通过observeOn操作符给他定义的线程<br>图：<br><img src="http://reactivex.io/documentation/operators/images/observeOn.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/observeOn.e.png" alt=""></p>
<h6 id="SubscribeOn操作符"><a href="#SubscribeOn操作符" class="headerlink" title="SubscribeOn操作符"></a><strong>SubscribeOn</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; subscribeOn(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>用于指定Observable运行call的时候的线程，或者说是Observable自身所在的线程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Log.i(TAG, Thread.currentThread().getName());</div><div class="line">       Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               Log.i(TAG, &quot;Observable = &quot;+Thread.currentThread().getName());</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread()).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-01 14:33:03.439 3927-3927/com.example.user.testproject I/RxJavaTest: main</div><div class="line">11-01 14:33:03.500 3927-3952/com.example.user.testproject I/RxJavaTest: Observable = RxNewThreadScheduler-1</div><div class="line">11-01 14:33:03.500 3927-3952/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:33:03.501 3927-3952/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:33:03.501 3927-3952/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div></pre></td></tr></table></figure></p>
<p>可以看到Observable所在的线程是我们给他指定的线程，Observer默认不在任何调度器上面执行，所以也跟着在这个线程上面执行，我们可以这样子指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Log.i(TAG, Thread.currentThread().getName());</div><div class="line">       Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               Log.i(TAG, &quot;Observable = &quot;+Thread.currentThread().getName());</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread())</div><div class="line">               .observeOn(AndroidSchedulers.mainThread())</div><div class="line">               .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>这样子Observer就可以在指定的不用于Observable所在的线程，注意这里需要引入RxAdnroid。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/subscribeOn.c.png" alt=""></p>
<h6 id="subscribe操作符"><a href="#subscribe操作符" class="headerlink" title="subscribe操作符"></a><strong>subscribe</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Subscription subscribe() //只是需要让Observable和Observer发生关联，不需要处理Observable发射的数据</div><div class="line">Subscription subscribe(final Action1&lt;? super T&gt; onNext);// 只是接受OnNext数据</div><div class="line">Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError)// 只是接受onNext和onError数据</div><div class="line">Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted)// 接受全部事件数据</div><div class="line">Subscription subscribe(final Observer&lt;? super T&gt; observer)// 作用跟上面的类似，可以处理所有Observable发射的事件数据。</div></pre></td></tr></table></figure>
<p>就是平常我们使用最多的一个操作符，用于关联Observable和Observer。他的例子就不写了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/B.forEach.png" alt=""></p>
<h6 id="timeInterval操作符"><a href="#timeInterval操作符" class="headerlink" title="timeInterval操作符"></a><strong>timeInterval</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;TimeInterval&lt;T&gt;&gt; timeInterval()</div><div class="line">Observable&lt;TimeInterval&lt;T&gt;&gt; timeInterval(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>他的作用是把源Observable发射的数据T装换为一个TimeInterval<t>对象，存储有他的值和该源数据跟前一个Observable数据发射的时间间隔。<br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               for (int i = 1; i &lt; 5; i++) &#123;</div><div class="line">                   subscriber.onNext(&quot;&quot; + i);</div><div class="line">                   try &#123;</div><div class="line">                       Thread.sleep(i * 100);</div><div class="line">                   &#125; catch (InterruptedException e) &#123;</div><div class="line">                       e.printStackTrace();</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread()).timeInterval().map(new Func1&lt;TimeInterval&lt;String&gt;, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(TimeInterval&lt;String&gt; time) &#123;</div><div class="line">               Log.i(TAG, &quot;前后相差时间：&quot; + time.getIntervalInMilliseconds()+&quot;  值：&quot;+time.getValue());</div><div class="line">               return time.getValue();</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe();</div></pre></td></tr></table></figure></t></p>
<p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11-01 14:53:02.878 21735-21749/? I/RxJavaTest: 前后相差时间：2  值：1</div><div class="line">11-01 14:53:02.980 21735-21749/? I/RxJavaTest: 前后相差时间：102  值：2</div><div class="line">11-01 14:53:03.182 21735-21749/? I/RxJavaTest: 前后相差时间：202  值：3</div><div class="line">11-01 14:53:03.483 21735-21749/? I/RxJavaTest: 前后相差时间：301  值：4</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/timeInterval.c.png" alt=""></p>
<h6 id="Timeout操作符"><a href="#Timeout操作符" class="headerlink" title="Timeout操作符"></a><strong>Timeout</strong>操作符</h6><p>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit)</div><div class="line">Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler)</div></pre></td></tr></table></figure></p>
<p>该操作符在两个Observable数据发射之前的时间间隔超出了timeout，就会发射一个TimeoutException给Observer的onError。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                for (int i=1;i&lt;=4;i++) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(i * 200);</div><div class="line">                        subscriber.onNext(&quot;&quot; + i);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                try &#123;</div><div class="line">                    Thread.currentThread().sleep(2000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.subscribeOn(Schedulers.newThread()).timeout(1,TimeUnit.SECONDS).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot;+e);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">11-01 15:20:03.978 13695-13710/? I/RxJavaTest: A</div><div class="line">11-01 15:20:04.181 13695-13710/? I/RxJavaTest: 1</div><div class="line">11-01 15:20:04.583 13695-13710/? I/RxJavaTest: 2</div><div class="line">11-01 15:20:05.183 13695-13710/com.example.user.testproject I/RxJavaTest: 3</div><div class="line">11-01 15:20:05.984 13695-13710/com.example.user.testproject I/RxJavaTest: 4</div><div class="line">11-01 15:20:06.985 13695-13709/com.example.user.testproject I/RxJavaTest: onErrorjava.util.concurrent.TimeoutException</div></pre></td></tr></table></figure></p>
<p>从这里可以看到是两个Observable数据发射的时间间隔，而不是总体的发射时间。<br><img src="http://reactivex.io/documentation/operators/images/timeout.2.png" alt=""><br>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Observable&lt;? extends T&gt; other)</div><div class="line">Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Observable&lt;? extends T&gt; other, Scheduler scheduler)</div></pre></td></tr></table></figure></p>
<p>这个函数可以在超时之后发射一个Observable座位补充，他是接着在源的数据之后发射，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">              subscriber.onNext(&quot;A&quot;);</div><div class="line">              for (int i = 1; i &lt;= 4; i++) &#123;</div><div class="line">                  try &#123;</div><div class="line">                      Thread.sleep(i * 200);</div><div class="line">                      subscriber.onNext(&quot;&quot; + i);</div><div class="line">                  &#125; catch (InterruptedException e) &#123;</div><div class="line">                      e.printStackTrace();</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              try &#123;</div><div class="line">                  Thread.currentThread().sleep(2000);</div><div class="line">              &#125; catch (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              subscriber.onNext(&quot;B&quot;);</div><div class="line">              subscriber.onCompleted();</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      ob.subscribeOn(Schedulers.newThread()).timeout(1, TimeUnit.SECONDS, Observable.just(&quot;G&quot;)).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void onCompleted() &#123;</div><div class="line">              Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onError(Throwable e) &#123;</div><div class="line">              Log.i(TAG, &quot;onError&quot; + e);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onNext(String s) &#123;</div><div class="line">              Log.i(TAG, s);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">11-01 15:25:24.379 18453-18468/? I/RxJavaTest: A</div><div class="line">11-01 15:25:24.582 18453-18468/? I/RxJavaTest: 1</div><div class="line">11-01 15:25:24.983 18453-18468/? I/RxJavaTest: 2</div><div class="line">11-01 15:25:25.584 18453-18468/com.example.user.testproject I/RxJavaTest: 3</div><div class="line">11-01 15:25:26.385 18453-18468/com.example.user.testproject I/RxJavaTest: 4</div><div class="line">11-01 15:25:27.388 18453-18467/com.example.user.testproject I/RxJavaTest: G</div><div class="line">11-01 15:25:27.388 18453-18467/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>这样子就可以让Observable顺利发射完成。<br><img src="http://reactivex.io/documentation/operators/images/timeout3.png" alt=""><br>第三种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; timeout(Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector)</div><div class="line">Observable&lt;T&gt;  timeout(Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector, Observable&lt;? extends T&gt; other)</div></pre></td></tr></table></figure></p>
<p>这个谓词，他返回一个跟源Observable对应的Observable，当该谓词的Observable发射终止，源Observable还没有发射数据的时候，就发射一个TimeoutException给Observer的onError。第二个函数是不发射给onError，而是在源数据的基础之上继续发射替补的other。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.currentThread().sleep(100);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.subscribeOn(Schedulers.newThread()).timeout(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;String&gt; call(String s) &#123;</div><div class="line">                return Observable.just(s).delay(50, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11-01 15:36:21.216 28118-28142/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 15:36:21.217 28118-28142/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 15:36:21.270 28118-28147/com.example.user.testproject I/RxJavaTest: onErrorjava.util.concurrent.TimeoutException</div></pre></td></tr></table></figure></p>
<p>第二个函数也是类似的。<br><img src="http://reactivex.io/documentation/operators/images/timeout5.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/timeout4.png" alt=""><br>第四种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; timeout(Func0&lt;? extends Observable&lt;U&gt;&gt; firstTimeoutSelector, Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector)</div><div class="line">Observable&lt;T&gt; timeout(Func0&lt;? extends Observable&lt;U&gt;&gt; firstTimeoutSelector, Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector, Observable&lt;? extends T&gt; other)</div></pre></td></tr></table></figure></p>
<p>这是可以给第一个Observable的数据设置超时，即当源Observable的第一个数据没有在firstTimeoutSelector的终止之前发射就会发射TimeoutException。其他的是跟上面类似，例子就不写了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/timeout6.png" alt=""></p>
<h6 id="Timestamp操作符"><a href="#Timestamp操作符" class="headerlink" title="Timestamp操作符"></a><strong>Timestamp</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Timestamped&lt;T&gt;&gt; timestamp()</div><div class="line">Observable&lt;Timestamped&lt;T&gt;&gt; timestamp(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>他的作用是把源数据包装一次，让它带有发射时间，包装之后的数据是Timestamped<t> ，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               try &#123;</div><div class="line">                   Thread.currentThread().sleep(100);</div><div class="line">               &#125; catch (InterruptedException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125;</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread()).timestamp().subscribe(new Action1&lt;Timestamped&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Timestamped&lt;String&gt; stringTimestamped) &#123;</div><div class="line">               Log.i(TAG, &quot;timestamp&quot; + stringTimestamped);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></t></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11-01 15:49:09.785 7365-7379/? I/RxJavaTest: timestampTimestamped(timestampMillis = 1478015349785, value = A)</div><div class="line">11-01 15:49:09.785 7365-7379/? I/RxJavaTest: timestampTimestamped(timestampMillis = 1478015349785, value = B)</div><div class="line">11-01 15:49:09.886 7365-7379/? I/RxJavaTest: timestampTimestamped(timestampMillis = 1478015349886, value = C)</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/timestamp.c.png" alt=""></p>
<h6 id="Using操作符"><a href="#Using操作符" class="headerlink" title="Using操作符"></a><strong>Using</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; using(</div><div class="line">            final Func0&lt;Resource&gt; resourceFactory,</div><div class="line">            final Func1&lt;? super Resource, ? extends Observable&lt;? extends T&gt;&gt; observableFactory,</div><div class="line">            final Action1&lt;? super Resource&gt; disposeAction)</div><div class="line"></div><div class="line">Observable&lt;T&gt; using(</div><div class="line">            final Func0&lt;Resource&gt; resourceFactory,</div><div class="line">            final Func1&lt;? super Resource, ? extends Observable&lt;? extends T&gt;&gt; observableFactory,</div><div class="line">            final Action1&lt;? super Resource&gt; disposeAction, boolean disposeEagerly)</div></pre></td></tr></table></figure>
<p>创建一个只在Observable生命周期内存在的一次性资源，需要释放的资源，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Observable.using(new Func0&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call() &#123;</div><div class="line">               // 创建资源</div><div class="line">               return &quot;Hello&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;, new Func1&lt;Object, Observable&lt;?&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;?&gt; call(Object o) &#123;</div><div class="line">               //创建资源对应的Observable对象</div><div class="line">               return Observable.just(o);</div><div class="line">           &#125;</div><div class="line">       &#125;, new Action1&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Object o) &#123;</div><div class="line">               // 释放资源</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Object o) &#123;</div><div class="line">               Log.i(TAG,o.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>其中第一个参数是创建资源，第二个参数是创建资源对应的Observable对象，第三个参数是释放资源。他适合与一些全局的一些需要被及时回收而我们需要确定他回收的资源。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/using.c.png" alt=""></p>
<h5 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h5><p>我们可以使用布尔操作符，对源数据Observable发送的数据进行变换或者是直接的布尔操作，来达到一些目的。</p>
<h6 id="all-操作符"><a href="#all-操作符" class="headerlink" title="all 操作符"></a><strong>all</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Boolean&gt; all(Func1&lt;? super T, Boolean&gt; predicate)</div></pre></td></tr></table></figure>
<p>用于判断Observable的所有数据是否满足某一个条件<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,3).all(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(Integer integer) &#123;</div><div class="line">               return integer&gt;9;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Boolean aBoolean) &#123;</div><div class="line">               Log.i(TAG, &quot;all&quot; + aBoolean.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是true，加入把条件改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">            public Boolean call(Integer integer) &#123;</div><div class="line">                return integer&gt;11;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>那么就是输出false了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/all.png" alt=""></p>
<h6 id="amb-操作符"><a href="#amb-操作符" class="headerlink" title="amb 操作符"></a><strong>amb</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; amb(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources)</div><div class="line">Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2)</div><div class="line">Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3)</div><div class="line">...... 还有其他的，同样是上面哪样子的</div></pre></td></tr></table></figure>
<p>amb操作符的作用是用于比较两个Observable，然后哪一个先发射数据就只是发射这个Observable的数据，抛弃其他的Observable数据，不论他第一个是发射了onError还是onComplete，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; o1 = Observable.range(20, 1).delay(200, TimeUnit.MILLISECONDS);</div><div class="line">        Observable&lt;Integer&gt; o2 = Observable.range(10, 1).delay(100, TimeUnit.MILLISECONDS);</div><div class="line"> </div><div class="line">        Observable.amb(o1, o2).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, &quot;amb==&quot; + integer.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">amb==10</div></pre></td></tr></table></figure></p>
<p>有一个ambWith操作符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; ambWith(Observable&lt;? extends T&gt; t1)</div></pre></td></tr></table></figure></p>
<p>他是一个非静态的，作用跟上面的一样。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/amb.png" alt=""></p>
<h6 id="contains-操作符"><a href="#contains-操作符" class="headerlink" title="contains 操作符"></a><strong>contains</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Boolean&gt; contains(final Object element)</div></pre></td></tr></table></figure>
<p>该操作符的作用是用于判断源数据时候包含某一个元素，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,5).contains(11).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public void call(Boolean aBoolean) &#123;</div><div class="line">             Log.i(TAG,aBoolean.toString());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是true，因为源数据的范围是10-14之间，包含11.<br>图：<br><img src="http://reactivex.io/documentation/operators/images/contains.png" alt=""></p>
<h6 id="defaultIfEmpty-操作符"><a href="#defaultIfEmpty-操作符" class="headerlink" title="defaultIfEmpty 操作符"></a><strong>defaultIfEmpty</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; defaultIfEmpty(final T defaultValue)</div></pre></td></tr></table></figure>
<p>该操作符的作用是在源Observable没有发射数据的时候发射一个默认数据，但是有onComplete()调用，表明他已经发射数据完毕，在没有数据发射的时候调用了onError是不会发射默认数据的，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onCompleted();</div><div class="line">//                subscriber.onError(new IllegalArgumentException(&quot;error&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.defaultIfEmpty(&quot;A&quot;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：A，假如是发射onError的时候则是只输出“error”，而不会输出A<br>图：<br><img src="http://reactivex.io/documentation/operators/images/defaultIfEmpty.c.png" alt=""></p>
<h6 id="sequenceEqual-操作符"><a href="#sequenceEqual-操作符" class="headerlink" title="sequenceEqual 操作符"></a><strong>sequenceEqual</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Boolean&gt; sequenceEqual(Observable&lt;? extends T&gt; first, Observable&lt;? extends T&gt; second)</div><div class="line">Observable&lt;Boolean&gt; sequenceEqual(Observable&lt;? extends T&gt; first, Observable&lt;? extends T&gt; second, Func2&lt;? super T, ? super T, Boolean&gt; equality)</div></pre></td></tr></table></figure>
<p>第一个函数，用于判断输入的两个Observable是否相同，包括发射长度，顺序，值，终止状态，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.sequenceEqual(Observable.just(&quot;A&quot;,&quot;B&quot;),Observable.just(&quot;A&quot;,&quot;B&quot;)).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Boolean aBoolean) &#123;</div><div class="line">                Log.i(TAG, aBoolean.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出就是true，把第二个Observable改为Observable.just(“B”,”A”)，输出就是false。<br>终止状态不同的时候，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; o1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Observable&lt;String&gt; o2 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onError(new IllegalArgumentException(&quot;Error&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        Observable.sequenceEqual(o1,o2).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Boolean aBoolean) &#123;</div><div class="line">                Log.i(TAG, aBoolean.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>就会输出了error。<br>第二个函数，他多了一个参数，是用于比较，自己确定规则的那种比较，两个Observable的值是否相同。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.sequenceEqual(Observable.just(&quot;A&quot;), Observable.just(&quot;A&quot;), new Func2&lt;String, String, Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(String s, String s2) &#123;</div><div class="line">               return s.equals(s2);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Boolean aBoolean) &#123;</div><div class="line">               Log.i(TAG, aBoolean.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>就是输出true，<br>图：<br><img src="http://reactivex.io/documentation/operators/images/sequenceEqual.png" alt=""></p>
<h6 id="skipUntil-操作符"><a href="#skipUntil-操作符" class="headerlink" title="skipUntil 操作符"></a><strong>skipUntil</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; skipUntil(Observable&lt;U&gt; other)</div></pre></td></tr></table></figure>
<p>用于废弃源Observable，知道other操作符符发射数据，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; s1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onNext(&quot;E&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(200);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        s1.subscribeOn(Schedulers.newThread())</div><div class="line">                .skipUntil(Observable.just(&quot;B&quot;)</div><div class="line">                .delay(100, TimeUnit.MILLISECONDS))</div><div class="line">                .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(String s) &#123;</div><div class="line">                        Log.i(TAG, s);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果是只输出了D，以为前面的C，E在other发射数据之前已经发射，所以会被丢弃。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/skipUntil.png" alt=""></p>
<h6 id="skipWhile-操作符"><a href="#skipWhile-操作符" class="headerlink" title="skipWhile 操作符"></a><strong>skipWhile</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; skipWhile(Func1&lt;? super T, Boolean&gt; predicate)</div></pre></td></tr></table></figure>
<p>他的作用在于可以自己定规则，忽略前面不符合条件的数据，但是当一旦返回了true，该数据就不会被发射，然后predicate谓词还是会被调用，但是当predicate返回了false之后就不会再次被调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; s1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onNext(&quot;E&quot;);</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">                subscriber.onNext(&quot;F&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        s1.skipWhile(new Func1&lt;String, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;skipWhile&quot;);</div><div class="line">                return s.equals(&quot;C&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: skipWhile</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: skipWhile</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: E</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: D</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: F</div></pre></td></tr></table></figure></p>
<p>可以看到C没有输出，而且调用了skipWhile两次，skipWhile返回了false之后就没有被再次调用而是直接发射了源Observable后面的数据。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/skipWhile.png" alt=""></p>
<h6 id="TakeUntil-操作符"><a href="#TakeUntil-操作符" class="headerlink" title="TakeUntil 操作符"></a><strong>TakeUntil</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; takeUntil(Observable&lt;? extends E&gt; other)</div></pre></td></tr></table></figure>
<p>他的作用在于other在发射一个数据或者是onComplete的时候，回去终止源Observable发射数据，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; o1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">              subscriber.onNext(&quot;A&quot;);</div><div class="line">              subscriber.onNext(&quot;B&quot;);</div><div class="line">              subscriber.onNext(&quot;C&quot;);</div><div class="line">              try &#123;</div><div class="line">                  Thread.sleep(200);</div><div class="line">              &#125; catch (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              subscriber.onNext(&quot;D&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      o1.subscribeOn(Schedulers.newThread())</div><div class="line">              .takeUntil(Observable.empty().delay(100, TimeUnit.MILLISECONDS))</div><div class="line">              .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                  @Override</div><div class="line">                  public void call(String s) &#123;</div><div class="line">                      Log.i(TAG, s);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11-02 14:24:02.505 11375-11396/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-02 14:24:02.505 11375-11396/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-02 14:24:02.505 11375-11396/com.example.user.testproject I/RxJavaTest: C</div></pre></td></tr></table></figure></p>
<p>可以看到other是在100ms之后再去发射数据的，observable在100ms之后发射的数据会被忽略。图：<br><img src="http://reactivex.io/documentation/operators/images/takeUntil.png" alt=""></p>
<h6 id="TakeWhile-操作符"><a href="#TakeWhile-操作符" class="headerlink" title="TakeWhile 操作符"></a><strong>TakeWhile</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; takeWhile(final Func1&lt;? super T, Boolean&gt; predicate)</div></pre></td></tr></table></figure>
<p>他的作用是通过predicate函数返回一个boolean值，假如是返回了true，则发射该数据，但是一旦返回来false，就终止源Observable的发射，同时调用他的onComplete()方法，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; o1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        o1.takeWhile(new Func1&lt;String, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;takeWhile==&quot;+s);</div><div class="line">                return s.equals(&quot;C&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;, new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;OnComplete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==A</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: OnComplete</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==B</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==C</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==D</div></pre></td></tr></table></figure></p>
<p>因为第一个数据就使得predicate返回了false，所以终止了发射，假如predicate换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">           public Boolean call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;takeWhile==&quot; + s);</div><div class="line">               return !s.equals(&quot;E&quot;);</div><div class="line">           &#125;</div></pre></td></tr></table></figure></p>
<p>则会输出全部，图：<br><img src="http://reactivex.io/documentation/operators/images/takeWhile.c.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/26/Android/开源项目学习/RxJavacmd/" data-id="civ9mcpil001ffwouv3vtbfxj" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava操作符/">RxJava操作符</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-资源学习/gitrerecommend" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/资源学习/gitrerecommend/" class="article-date">
  <time datetime="2016-10-16T15:10:10.204Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/资源/">资源</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/资源学习/gitrerecommend/">Git学习推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://git-scm.com/" target="_blank" rel="external">git</a></p>
<h3 id="推荐教程，中文版的"><a href="#推荐教程，中文版的" class="headerlink" title="推荐教程，中文版的"></a>推荐教程，中文版的</h3><p><a href="http://www.yiibai.com/git/" target="_blank" rel="external">Git教程</a><br><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a><br><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="external">git - 简易指南</a></p>
<h3 id="git代码管理"><a href="#git代码管理" class="headerlink" title="git代码管理"></a>git代码管理</h3><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow/" target="_blank" rel="external">官网</a><br><a href="http://www.ituring.com.cn/article/56870" target="_blank" rel="external">git flow</a></p>
<p><span id="busuanzi_container_site_pv"><br>    本站总访问量<span id="busuanzi_value_site_pv"></span>次<br></span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/16/资源学习/gitrerecommend/" data-id="civ9mcph50008fwouimooqvjz" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git学习资源/">git学习资源</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-资源学习/git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/资源学习/git命令/" class="article-date">
  <time datetime="2016-10-16T15:07:36.799Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/资源/">资源</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/资源学习/git命令/">Git常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h2><h3 id="git安装地址"><a href="#git安装地址" class="headerlink" title="git安装地址"></a>git安装地址</h3><p><a href="https://git-scm.com/download/win" target="_blank" rel="external">git.exe windows</a></p>
<h3 id="git的使用-1"><a href="#git的使用-1" class="headerlink" title="git的使用"></a>git的使用</h3><ul>
<li><p>查看帮助，所有的命令通用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git cmd --help //cmd是对应的命令，输入之后他会打开对应的网页</div></pre></td></tr></table></figure>
</li>
<li><p>clone命令，从远程仓库中copy代码到本地，方式一般常用的有两种方法<br>  1.1. https<br>  1.2. ssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 例如</div><div class="line">git clone git@github.com:liweijieok/android-open-project.git  //ssh</div><div class="line">git clone https://github.com/liweijieok/android-open-project.git //https</div></pre></td></tr></table></figure>
</li>
<li><p>本地基本配置，git config，配置用户名和邮箱，下面是配置全局的。就是整个git环境下的，还可以去配置一些快捷，比如commit命令可以配置为cm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 查看配置</div><div class="line">git config --list</div><div class="line">// 配置用户名和邮箱</div><div class="line">git config --global user.name &quot;youname&quot;</div><div class="line">git config --global user.email &quot;youemail&quot;</div><div class="line">// 配置命令别名，比如checkout可以简写为co</div><div class="line">git config --gloabl alias.co checkout</div><div class="line">//还可以配置其他的别名alias.xx xxx 其中xx 是别名 xxx是原来的操作名称</div></pre></td></tr></table></figure>
</li>
<li><p>本地创建git版本库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
</li>
<li><p>添加到git暂存区，就是可以把该文件列为git版本控制的范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 添加某一个文件到暂存区</div><div class="line">git add &lt;filename&gt; </div><div class="line">// 添加所有的文件到暂存区</div><div class="line">git add -A</div></pre></td></tr></table></figure>
</li>
<li><p>提交修改纳入版本库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m&quot;提交描述&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout branchName</div><div class="line">git checkout -b newBranch originBranch//新建分支，基于originbranch，然后切换过去，没有最好一个参数的时候则是默认从当前分支作为originbranch</div></pre></td></tr></table></figure>
</li>
<li><p>关联远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git remote add origin git@github.com:liweijie/xxx.git</div><div class="line">//其中git@github.com:liweijie/xxx.git是远程仓库的地址，有些是是ssh，有些时候是https</div><div class="line">git remote // 不带参数，列出已经存在的远程分支</div><div class="line">git remote -v //列出详细的信息，每一个远程分支都会带有一个url</div><div class="line">git remote remove origin// 取消与远程仓库的连接</div></pre></td></tr></table></figure>
</li>
<li><p>生成ssh密匙</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C youemail</div><div class="line">// 之后可以设置ssh的生成的文件名和密码，一般密码为空就行，之后会生成xxx.pub和xxx文件，前面是公钥，后面是私钥，公钥需要配置在git服务器上面</div></pre></td></tr></table></figure>
</li>
<li><p>分支管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//查看本地所有分支</div><div class="line">git brach</div><div class="line">// 查看所有分支</div><div class="line">git branch -a</div><div class="line">// 查看远程分支</div><div class="line">git bracnh -r</div><div class="line">// 生成新分支</div><div class="line">git branch branchName</div><div class="line">// 删除本地分支</div><div class="line">git branch -d branchName // 假如该分支没有被合并过会提示并没被合并过</div><div class="line">git branch -D branchName //不会有同时</div><div class="line">// 所以需要生成一个新的分支并且切换的话是</div><div class="line">git branch newbranch</div><div class="line">git checkout newbranch</div></pre></td></tr></table></figure>
</li>
<li><p>合并分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//当前分支合并别的分支，直接合并</div><div class="line">git merge otherName</div></pre></td></tr></table></figure>
</li>
<li><p>看起来没有merge的合并 rebase</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase otherBranch // rebase别的分支的提交作为本分支的提交</div></pre></td></tr></table></figure>
</li>
<li><p>rebase和merge的作用和区别 他们的作用是同样的把别的分支代码合并到自己本分支上面，不同之处：<br>1 假如你现在有基于远程分支origin 创建一个叫mywork的分支，原来的origin分支已经有了两个提交，如下：<br>使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b mywork origin //创建并且切换到mywork分支</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://my.csdn.net/uploads/201206/14/1339682677_4329.jpg" alt=""><br>然后与此同时，我们在mywork分支做了一些修改，变为了<br><img src="http://my.csdn.net/uploads/201206/14/1339682809_4752.jpg" alt=""><br>同时，又有别的人在origin分支上面做了修改并且提交了，如下<br><img src="http://my.csdn.net/uploads/201206/14/1339682809_4752.jpg" alt=""><br>假如我们使用merge，把origin分支pull下来，然后切换到mywork分支，然后把origin合并过来，结果是这样子的<br><img src="http://my.csdn.net/uploads/201206/14/1339682845_9921.jpg" alt=""><br>但是，我们想让他看起来是没有经过merge的，这样子分支上会清晰很多，方便管理，这时候使用rebase分支，他的原结果图是：<br><img src="http://my.csdn.net/uploads/201206/14/1339682976_4523.jpg" alt=""><br>使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase origin //当前分支是mywork，而且mywork分支已经pull下来了</div></pre></td></tr></table></figure></p>
<p>这时候，mywork分支会把该分支的所有提交废弃，并且同时生成补丁patch ，存放在.git/rebase目录下，然后把mywork分支更新为最新的origin分支，最后把保存的补丁应用到mywork分支上。<br><img src="http://my.csdn.net/uploads/201206/14/1339682915_7495.jpg" alt=""><br>当mywork分支更新后，他会指向这些新创建的提价，那些老的提交会被丢弃，如果允许垃圾收集命令git gc ，这些提交就会被删除。<br>当发生冲突的时候，git会停止rebase让你去解决冲突，在冲突解决完成后，使用git add .命令更新索引，无需执行git commit ，只需要执行git rebase -continue.。<br>所以，最终git merge和git rebase的区别就是git merge会保留所有的提交，会比较乱但是有注释，但是git rebase会比较的清晰，他会只有一条线。</p>
<p>出处：<a href="http://blog.csdn.net/wh_19910525/article/details/7554489" target="_blank" rel="external">git merge 和 git rebase 小结</a></p>
<ul>
<li><p>拉取远程分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div><div class="line">//比如</div><div class="line">git pull origin master:master // 拉取远程主机origin的master与本地的master分支合并</div><div class="line">// 假如是拉取远程主机的远程分支与当前分支合并，后面部分可以不写</div><div class="line">git pull origin master</div><div class="line">//等同于</div><div class="line">git fetch origin</div><div class="line">git merge origin/master</div><div class="line">//在某一些场合，git回自动在本地与远程分支之间，建立一种追踪关系(tracking)。</div><div class="line">//比如，在git clone的时候，所欲的本地分支默认与远程主机的同名分支建立追踪关系，也就是说，本地的master分支自动追踪origin/mater分支。</div><div class="line">//如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名</div><div class="line">git pull origin</div><div class="line">//如果当前分支只有一个追踪分支，连远程主机名都可以省略</div><div class="line">git pull</div><div class="line">//你也可以手动的建立这一种追踪关系</div><div class="line">git branch --set-upstream branchName origin/remoteBranch</div></pre></td></tr></table></figure>
</li>
<li><p>获取最新的远程版本库内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git fetch &lt;远程主机名&gt;//一般为origin</div><div class="line">//比如远程主机那里别人提交了新的分支，你本地需要获取，就可以</div><div class="line">git fetch origin //把origin远程主机的所有分支的更新</div><div class="line">//假如只是想取回特定分支的更新，可以指定分支名字</div><div class="line">git fetch origin</div></pre></td></tr></table></figure>
</li>
<li><p>推送本地更新到远程服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 需要注意的是他跟git pull是相反的 git pull origin remoteBranch:localBranch</div><div class="line">git push origin localBranch:remoteBranch </div><div class="line">//当推送分支和远程对应的分支存在追踪关系的时候，可以直接</div><div class="line">git push origin localBranch //远程不存在对应的分支的时候回自动新建并且建立追踪关系</div><div class="line">// 删除远程分支</div><div class="line">git push origin  :remoteBranch //其中&quot;:&quot;前面有一个空格不可以少，表示推送空白到远程，这样子就可以删除远程分支</div><div class="line">// 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略</div><div class="line">git push origin</div><div class="line">//假如当前分支与多个主机(一般是只有origin)，可以使用-u知道默认主机</div><div class="line">git push -u 远程主机名 localBranch:remoteBranch</div><div class="line">//推送本地的所有分支到远程</div><div class="line">git push --all origin</div><div class="line">//推送的时候加上tag，下面是表示推送所有的tag，需要注意是否有权限</div><div class="line">git push origin --tags</div></pre></td></tr></table></figure>
</li>
<li><p>打tag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git tag -a 标签号-m&quot;标签描述&quot;</div><div class="line">// 比如</div><div class="line">git tag -a V1.0 -m&quot;1.0版本完成&quot;</div><div class="line">//查看tag</div><div class="line">git tag</div><div class="line">//或者</div><div class="line">git tag -l</div><div class="line">//删除标签</div><div class="line">git tag -d 标签号</div><div class="line">git push origin tagName // 推送tag到远程服务器</div><div class="line">git push --tags // push所有的tag到远程服务器</div></pre></td></tr></table></figure>
</li>
<li><p>合并分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//合并别的分支到当前分支</div><div class="line">git merge branchName </div><div class="line">//合并分支</div><div class="line">git merge resultBranch feature 后者是被合并到前者那里</div></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//查看还没有被列入版本库的文件和还没有被commit的文件</div><div class="line">git status</div></pre></td></tr></table></figure>
</li>
<li><p>查看commit但是没有被push的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git log localBranch ^origin/remoteBranch  // 查看commit没有被push的详细</div><div class="line">git cherry -v //查看commit没有push的版本号</div></pre></td></tr></table></figure>
</li>
<li><p>保存状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 场景是你需要切换分支，但是当前分支的修改还不能提价</div><div class="line">git stash//保存当前分支修改状态</div><div class="line">// 修改完其他分支的东西回来，需要还原</div><div class="line">git stash pop //恢复原来没有commit的修改</div><div class="line">//列出stash</div><div class="line">git stash list</div></pre></td></tr></table></figure>
</li>
<li><p>列出提交日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//列出所有历史记录</div><div class="line">git log</div><div class="line">// 列出提交记录的前n条</div><div class="line">git log -n</div><div class="line">// 显示简要的增加行数统计，每次提交的文件变更,-n作用同上，可以省略</div><div class="line">git log --stat -n</div><div class="line">//跟上面一样，不过更加强大,更改的地方会显示出来</div><div class="line">git log -p -n</div><div class="line">//一行显示，只显示hash和提交说明</div><div class="line">git log --pretty=online</div><div class="line">// 图形化显示</div><div class="line">git log --pretty=format:&quot;格式化内容&quot; --graph</div><div class="line">//比如</div><div class="line">git log --pretty=format:&quot;%H %s&quot; --graph -n //表示显示提交对象的完整hash和提交说明</div><div class="line">//format可选有</div><div class="line">%H  提交对象（commit）的完整哈希字串</div><div class="line">%h  提交对象的简短哈希字串</div><div class="line">%T  树对象（tree）的完整哈希字串</div><div class="line">%t  树对象的简短哈希字串</div><div class="line">%P  父对象（parent）的完整哈希字串</div><div class="line">%p  父对象的简短哈希字串</div><div class="line">%an 作者（author）的名字</div><div class="line">%ae 作者的电子邮件地址</div><div class="line">%ad 作者修订日期（可以用 -date= 选项定制格式）</div><div class="line">%ar 作者修订日期，按多久以前的方式显示</div><div class="line">%cn 提交者(committer)的名字</div><div class="line">%ce 提交者的电子邮件地址</div><div class="line">%cd 提交日期</div><div class="line">%cr 提交日期，按多久以前的方式显示</div><div class="line">%s  提交说明</div></pre></td></tr></table></figure>
</li>
<li><p>再次修改gitignore文件并且生效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//场景是一些不需要被提价版本库的文件以及被提交了，这时候需要把他重新在版本库中去除</div><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m&quot;update .gitignore&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>合并commit，多钟方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">第一种</div><div class="line">git commit -a --amend -m&quot;message&quot; //这个操作会把之前一个的commit合并到当前的这个commit当中</div><div class="line">第二种</div><div class="line">git reset --soft HEAD^  // 就是取消最后的commit</div><div class="line">git commit --amend //这样子的结果就是最后一次的commit合并到上一次当中</div><div class="line">第三种，使用rebase命令</div><div class="line">git rebase -i commitid</div><div class="line">s/spuash 代表他要和上一个合并为同一个</div><div class="line">pick 命令代表他自己不会和上一个一起合并</div></pre></td></tr></table></figure>
</li>
<li><p>LInux的一些简单命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//载入修改文件内容</div><div class="line">vi &lt;filename&gt;</div><div class="line">//一般退出，比如查看了log</div><div class="line">j//向下</div><div class="line">k//向上</div><div class="line">i //插入修改</div><div class="line">//退出保存：</div><div class="line">Esc+&quot;:&quot;+&quot;wq&quot;</div><div class="line">//文件没有被改动</div><div class="line">Esc+&quot;:&quot;+&quot;q&quot;</div><div class="line">//不保存推出</div><div class="line">Esc+&quot;:&quot;+&quot;q!&quot;</div><div class="line">//强制推出:</div><div class="line">Esc+&quot;:&quot;+&quot;!&quot;、</div><div class="line">//查看文件</div><div class="line">cat &lt;filename&gt;</div><div class="line">//进入某一个文件夹</div><div class="line">cd &lt;dirPath&gt;</div><div class="line">//新建文件</div><div class="line">mkdir &lt;dirname&gt; &lt;dirname2&gt;</div><div class="line">//删除文件</div><div class="line">rm</div><div class="line">//列出文件夹下的文件</div><div class="line">ls</div><div class="line">//列出路径</div><div class="line">pwd</div><div class="line">注意：命令都是小写</div></pre></td></tr></table></figure>
</li>
</ul>
<p><span id="busuanzi_container_site_pv"><br>    本站总访问量<span id="busuanzi_value_site_pv"></span>次<br></span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/16/资源学习/git命令/" data-id="civ9mcpgy0005fwou61g0kokz" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git命令/">git命令</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/开源项目学习/RxRecomment" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/Android/开源项目学习/RxRecomment/" class="article-date">
  <time datetime="2016-10-16T15:04:28.081Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/开源项目学习/">开源项目学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/Android/开源项目学习/RxRecomment/">RxJava阅读推荐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="external">RxJava官网</a></p>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a><br><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a></p>
<h3 id="简书"><a href="#简书" class="headerlink" title="简书"></a>简书</h3><p><a href="http://www.jianshu.com/p/3a188b995daa#" target="_blank" rel="external">RxJava系列</a><br><a href="http://www.jianshu.com/p/6d1ef9f43cdc#" target="_blank" rel="external">详细解析RxAndroid的使用方式</a></p>
<h3 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h3><p><a href="http://gold.xitu.io/entry/5695c3ba60b2d6907c9081ef" target="_blank" rel="external">RxJava 的周末狂欢</a></p>
<h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p><a href="http://blog.csdn.net/IO_Field/article/category/6209962" target="_blank" rel="external">RxJava</a><br><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external"> 深入浅出RxJava</a><br><a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="external">RxBinding</a><br><a href="http://blog.csdn.net/axuanqq/article/category/6044339" target="_blank" rel="external">小炫风技术旅行</a><br><a href="http://blog.csdn.net/nicolelili1/article/details/52192012" target="_blank" rel="external">StringObservable</a></p>
<h3 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h3><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html" target="_blank" rel="external">ReactiveX文档中文翻译</a></p>
<h3 id="Rx例子"><a href="#Rx例子" class="headerlink" title="Rx例子"></a>Rx例子</h3><p><a href="https://github.com/jiang111/RxJavaApp" target="_blank" rel="external">RxJavaApp</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/16/Android/开源项目学习/RxRecomment/" data-id="civ9mcphu000nfwoudqlyxeyo" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava推荐/">RxJava推荐</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/自定义View/AnimSwitchView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/16/Android/自定义View/AnimSwitchView/" class="article-date">
  <time datetime="2016-10-16T14:56:29.000Z" itemprop="datePublished">2016-10-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/自定义View/">自定义View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/16/Android/自定义View/AnimSwitchView/">自定义SwitchView升级版</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="自定义SwitchView升级版"><a href="#自定义SwitchView升级版" class="headerlink" title="自定义SwitchView升级版"></a>自定义SwitchView升级版</h3><p>效果图：<br><img src="http://ocxgpwj6l.bkt.clouddn.com/animswitch.gif" alt=""></p>
<p>在上一片文章中，我们只是在ACTION_MOVE中有动画效果，在这一片中，我们会在ACTION_DOWN和ACTION_UP中带有动画。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>关于自定义的属性和初始化那些，跟上一篇文章类似，假如你还没有阅读，请先阅读上一篇文章：<a href="http://liweijieok.github.io/2016/10/15/Android/%E8%87%AA%E5%AE%9A%E4%B9%89View/TransitionSwitchView/" target="_blank" rel="external">自定义有动画的Switch控件</a><br>我们现在需要处理的是down和up事件，我们就需要添加一些属性去标记，比如down的位置，up之后应该是去到那里，每次重绘的spec是多少。所以我们添加了如下一些属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 动画结束的位置</div><div class="line">     */</div><div class="line">    private float animEnd;</div><div class="line">    /**</div><div class="line">     * 每次更新的长度</div><div class="line">     */</div><div class="line">    private float perAnim;</div><div class="line">    /**</div><div class="line">     * 分开5次更新</div><div class="line">     */</div><div class="line">    private static final int SEPARATION_LENGHT = 5;//分开五次更新</div><div class="line">    /**</div><div class="line">     * 是否有动画</div><div class="line">     */</div><div class="line">    private boolean hasAnim;</div><div class="line">    /**</div><div class="line">     * 动画方向，true为向右，false为向左</div><div class="line">     */</div><div class="line">    private boolean animDirection;</div></pre></td></tr></table></figure></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在drawCircle中去判断时候需要重绘动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 画圆</div><div class="line">    *</div><div class="line">    * @param canvas</div><div class="line">    * @param isChecked</div><div class="line">    */</div><div class="line">   private void drawCircle(Canvas canvas, boolean isChecked) &#123;</div><div class="line">       @ColorInt int currentColor = isChecked ? enableCircleColor : disCircleColor;</div><div class="line">       mPaint.setColor(currentColor);</div><div class="line">       mPaint.setStyle(Paint.Style.FILL);</div><div class="line">       canvas.drawCircle(circleX, circleY, radius, mPaint);</div><div class="line">       if (hasAnim) &#123;</div><div class="line">           drawWithAnim();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 画动画</div><div class="line">    */</div><div class="line">   private void drawWithAnim() &#123;</div><div class="line">       postDelayed(new Runnable() &#123;</div><div class="line">           @Override</div><div class="line">           public void run() &#123;</div><div class="line">               //右动画</div><div class="line">               if (animDirection) &#123;</div><div class="line">                   if (circleX + perAnim &gt;= animEnd) &#123; //是否到终点</div><div class="line">                       circleX = animEnd;</div><div class="line">                       hasAnim = false;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       circleX += perAnim;</div><div class="line">                   &#125;</div><div class="line">               &#125; else &#123; //左动画</div><div class="line">                   if (circleX - perAnim &lt;= animEnd) &#123;//是否到终点</div><div class="line">                       circleX = animEnd;</div><div class="line">                       hasAnim = false;</div><div class="line">                   &#125; else &#123;</div><div class="line">                       circleX -= perAnim;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               update();</div><div class="line">           &#125;</div><div class="line">       &#125;, 20);// 20ms画一次</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>那么，我们再down的时候怎么判断时候需要动画呢？逻辑是：</p>
<ol>
<li>首先这个点action假如是在圆里面则没有动画</li>
<li>假如是在圆的右边，则是右动画，需要注意判断时候超出边界</li>
<li><p>假如是在圆的左边则是左动画，需要注意不要超出边界</p>
<p>代码如下</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 是否有按下动画</div><div class="line">     *</div><div class="line">     * @param x</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean calculateDownAnim(float x) &#123;</div><div class="line">        if (x &gt;= circleX - radius &amp;&amp; x &lt;= circleX + radius) &#123;</div><div class="line">            if (x &lt;= radius) &#123;//在边界</div><div class="line">                circleX = radius;</div><div class="line">            &#125; else if (x + radius &gt;= width) &#123; //在边界</div><div class="line">                circleX = (width - radius);</div><div class="line">            &#125; else &#123;</div><div class="line">                circleX = x;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        perAnim = Math.abs(animEnd - circleX)/SEPARATION_LENGHT;</div><div class="line">        animDirection = isChecked;</div><div class="line">        // 计算动画起始位置和每次长度</div><div class="line">        if (x &gt; circleX + radius) &#123; // 右动画</div><div class="line">            if (x &gt;= width - radius) &#123;</div><div class="line">                animEnd = width - radius;</div><div class="line">            &#125; else &#123;</div><div class="line">                animEnd = x;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123; //左动画</div><div class="line">            if (x &lt; radius) &#123;</div><div class="line">                animEnd = radius;</div><div class="line">            &#125; else &#123;</div><div class="line">                animEnd = x;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于up事件则是比较简单，因为他的end位置只有两种，一个是circleX为radius，一个circleX为width-radius，然后默认up都是带有动画的就好，所以判断如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   * 是否有结束动画</div><div class="line">   *</div><div class="line">   * @param x</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  private boolean calculateUpAnim(float x) &#123;</div><div class="line">      // 如果在边界</div><div class="line">      animEnd = hasHalfWidth(x) ? width - radius : radius;</div><div class="line">      perAnim = Math.abs(animEnd - circleX) / SEPARATION_LENGHT;</div><div class="line">      animDirection = isChecked;</div><div class="line">      return true;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这样子，我们就完成了整一个带有移动动画的SwitchView控件了。</p>
<p><a href="https://github.com/liweijieok/SilmpleView" target="_blank" rel="external">源码下载</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/16/Android/自定义View/AnimSwitchView/" data-id="civ9mcphq000jfwou9efum2g0" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/带有move-up-down-动画的View/">带有move,up,down 动画的View</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自定义View/">自定义View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/自定义View/TransitionSwitchView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/15/Android/自定义View/TransitionSwitchView/" class="article-date">
  <time datetime="2016-10-15T14:56:29.000Z" itemprop="datePublished">2016-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/自定义View/">自定义View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/15/Android/自定义View/TransitionSwitchView/">自定义带有move动画的SwitchView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="自定义有动画的Switch控件"><a href="#自定义有动画的Switch控件" class="headerlink" title="自定义有动画的Switch控件"></a>自定义有动画的Switch控件</h4><p>效果图<br><img src="http://ocxgpwj6l.bkt.clouddn.com/switch.gif" alt=""></p>
<h5 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h5><p>我们需要一个类型Android Switch的功能，但是系统带有的有点丑，我们自己自定义一个带有动画的Switch，完全使用自定义View实现，他是可以根据手势进行move，以及过半时候的颜色装换</p>
<h5 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h5><p>首先，我们需要线条和圆的未打开和已经打开的状态颜色，圆的半径，线条的宽度，已经是否是打开状态这几个属性，定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;declare-styleable name=&quot;TransitionSwitchViewStyle&quot;&gt;</div><div class="line">        &lt;attr name=&quot;transitionCircleEnableColor&quot; format=&quot;color|reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;transitionCircleDisColor&quot; format=&quot;color|reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;transitionLineEnableColor&quot; format=&quot;color|reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;transitionLineDisColor&quot; format=&quot;color|reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;transitionCircleRadius&quot; format=&quot;dimension|reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;transitionLineWidth&quot; format=&quot;dimension|reference&quot;/&gt;</div><div class="line">        &lt;attr name=&quot;transitionIsChecked&quot; format=&quot;boolean&quot;/&gt;</div><div class="line">    &lt;/declare-styleable&gt;</div></pre></td></tr></table></figure></p>
<h5 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h5><p>我们需要重写onTouchEvent，同时需要返回true，然后move和up事件得以响应。<br>对于线条而言，他的起始点事固定的，宽度自己定义，改变的知识颜色，所以我们的一些东西不要在onMeasure中去初始化，不然重绘的时候会执行多次，影响效率。<br>对于圆而言，他的y坐标也是固定的 改变的是x位置和颜色，所以，我们需要在touch事件同不断改变x，同时重绘view，需要注意的是，同时我们需要判断当前touch的位置，是否过半了，假如是过半了我们就要改变线条和圆的颜色。</p>
<h5 id="核心代码具体实现，"><a href="#核心代码具体实现，" class="headerlink" title="核心代码具体实现，"></a>核心代码具体实现，</h5><p>首先是继承View<br>初始化方法,获取属性值和初始化画笔<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private void init(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class="line">       TypedArray array = context.getTheme().obtainStyledAttributes(attrs, R.styleable.TransitionSwitchViewStyle, defStyleAttr, 0);</div><div class="line">       enableCircleColor = array.getColor(R.styleable.TransitionSwitchViewStyle_transitionCircleEnableColor, DEFAULT_ENABLE_COLOR);</div><div class="line">       disCircleColor = array.getColor(R.styleable.TransitionSwitchViewStyle_transitionCircleDisColor, DEFAULT_DIS_COLOR);</div><div class="line">       enableLineColor = array.getColor(R.styleable.TransitionSwitchViewStyle_transitionLineEnableColor, DEFAULT_ENABLE_COLOR);</div><div class="line">       disLineColor = array.getColor(R.styleable.TransitionSwitchViewStyle_transitionLineDisColor, DEFAULT_DIS_COLOR);</div><div class="line">       isChecked = array.getBoolean(R.styleable.TransitionSwitchViewStyle_transitionIsChecked, false);</div><div class="line">       radius = array.getDimension(R.styleable.TransitionSwitchViewStyle_transitionCircleRadius, 10);</div><div class="line">       lineWidth = array.getDimension(R.styleable.TransitionSwitchViewStyle_transitionLineWidth, 10);</div><div class="line">       array.recycle();</div><div class="line">       mPaint = new Paint();</div><div class="line">       setBackgroundColor(Color.TRANSPARENT);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>onMeasure方法，因为他在重绘阶段是不会再次调用的，我们需要在里面去初始化一些定了就不会变的东西，而onDraw方法是每次都会被调用，所以不适合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       setMeasuredDimension(widthMeasureSpec, heightMeasureSpec);</div><div class="line">       circleX = isChecked ? (int) (getWidth() - radius) : (int) radius;</div><div class="line">       circleY = getHeight() / 2;</div><div class="line">       lineLeft = 0;</div><div class="line">       lineBottom = lineTop = getMeasuredHeight() / 2;</div><div class="line">       lineRight = (int) (getMeasuredWidth() - radius);</div><div class="line">       width = getMeasuredWidth();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>onDraw方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">  protected void onDraw(Canvas canvas) &#123;</div><div class="line">      super.onDraw(canvas);</div><div class="line">      drawLine(canvas, isChecked);</div><div class="line">      drawCircle(canvas, isChecked);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  /**</div><div class="line">   *  画线</div><div class="line">   * @param canvas</div><div class="line">   * @param isChecked</div><div class="line">   */</div><div class="line">  private void drawLine(Canvas canvas, boolean isChecked) &#123;</div><div class="line">      @ColorInt int currentColor = isChecked ? enableLineColor : disLineColor;</div><div class="line">      mPaint.setColor(currentColor);</div><div class="line">      mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">      mPaint.setStrokeWidth(lineWidth);</div><div class="line">      canvas.drawLine(lineLeft, lineTop, lineRight, lineBottom, mPaint);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">/**</div><div class="line">   * 画圆</div><div class="line">   *</div><div class="line">   * @param canvas</div><div class="line">   * @param isChecked</div><div class="line">   */</div><div class="line">  private void drawCircle(Canvas canvas, boolean isChecked) &#123;</div><div class="line">      @ColorInt int currentColor = isChecked ? enableCircleColor : disCircleColor;</div><div class="line">      mPaint.setColor(currentColor);</div><div class="line">      mPaint.setStyle(Paint.Style.FILL);</div><div class="line">      canvas.drawCircle(circleX, circleY, radius, mPaint);</div><div class="line">      drawCircleAnim();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最重要的onTouch方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">       int action = event.getAction();</div><div class="line">       switch (action) &#123;</div><div class="line">           case MotionEvent.ACTION_DOWN:</div><div class="line">               updateCircleX(event.getX(), false);</div><div class="line">               break;</div><div class="line">           case MotionEvent.ACTION_MOVE:</div><div class="line">               updateCircleX(event.getX(), false);</div><div class="line">               break;</div><div class="line">           case MotionEvent.ACTION_UP:</div><div class="line">               // 结束事件</div><div class="line">               updateCircleX(event.getX(), true);</div><div class="line">               break;</div><div class="line">       &#125;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 更新x坐标</div><div class="line">    *</div><div class="line">    * @param x</div><div class="line">    * @param isActionUp</div><div class="line">    */</div><div class="line">   private void updateCircleX(float x, boolean isActionUp) &#123;</div><div class="line">       if (isActionUp) &#123;</div><div class="line">           isChecked = hasHalfWidth(x);</div><div class="line">           // 加入重绘动画</div><div class="line">           drawAninCircle(circleX, x);</div><div class="line">           if (changeListener != null) &#123;</div><div class="line">               changeListener.onCheckChange(this,isChecked);</div><div class="line">           &#125;</div><div class="line">       &#125; else if (x &lt;= radius) &#123;    // 保证不会画出边界</div><div class="line">           circleX = (int) radius;</div><div class="line">           isChecked = false;</div><div class="line">           update();</div><div class="line">       &#125; else if (x &gt;= getMeasuredWidth() - radius) &#123;</div><div class="line">           circleX = (int) (getMeasuredWidth() - radius);</div><div class="line">           isChecked = true;</div><div class="line">           update();</div><div class="line">       &#125; else &#123;</div><div class="line">           // 判断x是否过半</div><div class="line">           isChecked = hasHalfWidth(x);</div><div class="line">           circleX = (int) x;</div><div class="line">           update();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 重绘</div><div class="line">    */</div><div class="line">   public void update() &#123;</div><div class="line">       if (LiWeiJieUtil.isUIThread()) &#123;</div><div class="line">           invalidate();</div><div class="line">       &#125; else &#123;</div><div class="line">           postInvalidate();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private boolean hasHalfWidth(float x) &#123;</div><div class="line">       return x &gt; (width / 2);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>还有一个难点就是如何去画在ActionUP之后的动画，我们首先在onAction Up之后判断他时候有必要，比如当前已经在两边定点了<br>画动画的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 画action up之后的动画</div><div class="line">    */</div><div class="line">   private void drawCircleAnim() &#123;</div><div class="line">       if (hasAnim) &#123;</div><div class="line">           postDelayed(new Runnable() &#123;</div><div class="line">               @Override</div><div class="line">               public void run() &#123;</div><div class="line">                   // 剩余部分分开20次画</div><div class="line">                   if (hasHalfWidth(circleX)) &#123;</div><div class="line">                       // 向右</div><div class="line">                       if (circleX + everyTimeDrawWidth &gt;= width-radius) &#123;</div><div class="line">                           circleX = (int) (width - radius);</div><div class="line">                           hasAnim = false;</div><div class="line">                           everyTimeDrawWidth = 0;</div><div class="line">                       &#125;else&#123;</div><div class="line">                           circleX+=everyTimeDrawWidth;</div><div class="line">                       &#125;</div><div class="line">                   &#125;else &#123;</div><div class="line">                       // 向左</div><div class="line">                       if (circleX-everyTimeDrawWidth &lt;= radius) &#123;</div><div class="line">                           circleX = (int) radius;</div><div class="line">                           hasAnim = false;</div><div class="line">                           everyTimeDrawWidth = 0;</div><div class="line">                       &#125;else&#123;</div><div class="line">                           circleX-=everyTimeDrawWidth;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   update();</div><div class="line">               &#125;</div><div class="line">           &#125;, 20);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这样子我们就完成了自定义Switch空间的完整流程。</p>
<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;com.liweijie.view.silmpleswitchbtn.TransitionSwitchView</div><div class="line">       android:id=&quot;@+id/transition&quot;</div><div class="line">       android:layout_width=&quot;80dp&quot;</div><div class="line">       android:layout_height=&quot;30dp&quot;</div><div class="line">       app:transitionCircleDisColor=&quot;#333333&quot;</div><div class="line">       app:transitionCircleEnableColor=&quot;#ff0000&quot;</div><div class="line">       app:transitionLineWidth=&quot;5dp&quot;</div><div class="line">       app:transitionIsChecked=&quot;true&quot;</div><div class="line">       app:transitionCircleRadius=&quot;10dp&quot;</div><div class="line">       app:transitionLineDisColor=&quot;#333333&quot;</div><div class="line">       app:transitionLineEnableColor=&quot;#ff0000&quot; /&gt;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/liweijieok/SilmpleView" target="_blank" rel="external">源码下载</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/15/Android/自定义View/TransitionSwitchView/" data-id="civ9mcphy000ofwouh337xmzu" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/带有move动画的View/">带有move动画的View</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自定义View/">自定义View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/自定义View/DynamicProgress" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/14/Android/自定义View/DynamicProgress/" class="article-date">
  <time datetime="2016-10-14T14:56:29.000Z" itemprop="datePublished">2016-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/自定义View/">自定义View</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/14/Android/自定义View/DynamicProgress/">自定义具有透明度变化和前进的ProgressBar</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自定义渐进的进度条"><a href="#自定义渐进的进度条" class="headerlink" title="自定义渐进的进度条"></a>自定义渐进的进度条</h2><p>结果图<img src="http://ocxgpwj6l.bkt.clouddn.com/GIF.gif" alt=""></p>
<h3 id="自定义进度条的需求"><a href="#自定义进度条的需求" class="headerlink" title="自定义进度条的需求"></a>自定义进度条的需求</h3><p>需求是：他可以根据进度的多少显示进度条，然后同时改变进度显示的透明度和当前进度，比如50%的时候显示的进度是50分，透明度是当前颜色的一半透明度。进度是70%的时候，则是70%的透明度。<br>
        
          <p class="article-more-link">
            <a href="/2016/10/14/Android/自定义View/DynamicProgress/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/14/Android/自定义View/DynamicProgress/" data-id="civ9mcphr000kfwouf5la7czq" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自定义View/">自定义View</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/进度和透明度变化的ProgressBar/">进度和透明度变化的ProgressBar</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
<div class="widget tag">
  <h3 class="title">Categorieën</h3>
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/开源项目学习/">开源项目学习</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/自定义View/">自定义View</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/资源/">资源</a><span class="category-list-count">2</span></li></ul> 
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava推荐/">RxJava推荐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava操作符/">RxJava操作符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git命令/">git命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git学习资源/">git学习资源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle构建/">gradle构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带有move-up-down-动画的View/">带有move,up,down 动画的View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/带有move动画的View/">带有move动画的View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义View/">自定义View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进度和透明度变化的ProgressBar/">进度和透明度变化的ProgressBar</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/RxJava推荐/" style="font-size: 10px;">RxJava推荐</a> <a href="/tags/RxJava操作符/" style="font-size: 10px;">RxJava操作符</a> <a href="/tags/git命令/" style="font-size: 10px;">git命令</a> <a href="/tags/git学习资源/" style="font-size: 10px;">git学习资源</a> <a href="/tags/gradle构建/" style="font-size: 10px;">gradle构建</a> <a href="/tags/带有move-up-down-动画的View/" style="font-size: 10px;">带有move,up,down 动画的View</a> <a href="/tags/带有move动画的View/" style="font-size: 10px;">带有move动画的View</a> <a href="/tags/自定义View/" style="font-size: 20px;">自定义View</a> <a href="/tags/进度和透明度变化的ProgressBar/" style="font-size: 10px;">进度和透明度变化的ProgressBar</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/07/gradle/gradle-java1/">Gradle构建java程序一</a>
          </li>
        
          <li>
            <a href="/2016/10/26/Android/开源项目学习/RxJavacmd/">RxJava全部操作符例子</a>
          </li>
        
          <li>
            <a href="/2016/10/16/资源学习/gitrerecommend/">Git学习推荐</a>
          </li>
        
          <li>
            <a href="/2016/10/16/资源学习/git命令/">Git常用命令</a>
          </li>
        
          <li>
            <a href="/2016/10/16/Android/开源项目学习/RxRecomment/">RxJava阅读推荐</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 rabbit<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>