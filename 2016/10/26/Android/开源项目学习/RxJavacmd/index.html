<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RxJava操作符," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="RXJava好处流行框架，流处理，逻辑清晰，网络处理方便，不再使用Handler，异步操作，简洁，哪怕是逻辑上面复杂，代码程度上面也能够做到简洁，与Retrofit2.0完美结合，多操作符。
RXJava相关依赖12compile &amp;apos;io.reactivex:rxjava:1.1.6&amp;apos;compile &amp;apos;io.reactivex:rxandroid:1.2.1&amp;apos">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava全部操作符例子">
<meta property="og:url" content="http://yoursite.com/2016/10/26/Android/开源项目学习/RxJavacmd/index.html">
<meta property="og:site_name" content="黎伟杰">
<meta property="og:description" content="RXJava好处流行框架，流处理，逻辑清晰，网络处理方便，不再使用Handler，异步操作，简洁，哪怕是逻辑上面复杂，代码程度上面也能够做到简洁，与Retrofit2.0完美结合，多操作符。
RXJava相关依赖12compile &amp;apos;io.reactivex:rxjava:1.1.6&amp;apos;compile &amp;apos;io.reactivex:rxandroid:1.2.1&amp;apos">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/create.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/just.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/from.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/defer.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/interval.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/range.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/repeat.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timer.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/empty.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/never.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/throw.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/flatMap.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/concatMap.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/switchMap.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/cast.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/groupBy.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/Buffer.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.f.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.key.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ignoreElements.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/zip.o.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/zip.i.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/switch.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/startWith.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorReturn.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorResumeNext.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onExceptionResumeNextViaObservable.png">
<meta property="og:image" content="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retry.C.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/materialize.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/dematerialize.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/delay.o.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/delay.oo.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/delaySubscription.o.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnEach.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnNext.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnSubscribe.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnUnsubscribe.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnCompleted.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnError.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doOnTerminate.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/doAfterTerminate.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/finallyDo.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/serialize.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/observeOn.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/observeOn.e.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/subscribeOn.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/B.forEach.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timeInterval.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timeout.2.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timeout3.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timeout5.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timeout4.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timeout6.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/timestamp.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/using.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/all.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/amb.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/contains.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/defaultIfEmpty.c.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/sequenceEqual.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/skipUntil.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/skipWhile.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/takeUntil.png">
<meta property="og:image" content="http://reactivex.io/documentation/operators/images/takeWhile.c.png">
<meta property="og:updated_time" content="2016-11-04T14:38:04.812Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava全部操作符例子">
<meta name="twitter:description" content="RXJava好处流行框架，流处理，逻辑清晰，网络处理方便，不再使用Handler，异步操作，简洁，哪怕是逻辑上面复杂，代码程度上面也能够做到简洁，与Retrofit2.0完美结合，多操作符。
RXJava相关依赖12compile &amp;apos;io.reactivex:rxjava:1.1.6&amp;apos;compile &amp;apos;io.reactivex:rxandroid:1.2.1&amp;apos">
<meta name="twitter:image" content="http://reactivex.io/documentation/operators/images/create.c.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/10/26/Android/开源项目学习/RxJavacmd/"/>


  <title> RxJava全部操作符例子 | 黎伟杰 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">黎伟杰</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">个人技术博客</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RxJava全部操作符例子
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-26T23:34:11+08:00" content="2016-10-26">
              2016-10-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/开源项目学习/" itemprop="url" rel="index">
                    <span itemprop="name">开源项目学习</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="RXJava好处"><a href="#RXJava好处" class="headerlink" title="RXJava好处"></a>RXJava好处</h4><p>流行框架，流处理，逻辑清晰，网络处理方便，不再使用Handler，异步操作，简洁，哪怕是逻辑上面复杂，代码程度上面也能够做到简洁，与Retrofit2.0完美结合，多操作符。</p>
<h5 id="RXJava相关依赖"><a href="#RXJava相关依赖" class="headerlink" title="RXJava相关依赖"></a>RXJava相关依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile &apos;io.reactivex:rxjava:1.1.6&apos;</div><div class="line">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</div></pre></td></tr></table></figure>
<h4 id="RXJava的使用"><a href="#RXJava的使用" class="headerlink" title="RXJava的使用"></a>RXJava的使用</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>RxJava基于的是观察者模式，类似订阅-发布，也类似Android的View的一些Listener监听<br>主要是有下面三个概念</p>
<ol>
<li>Observable 被观察者</li>
<li>Observer 观察者，是一个接口</li>
<li>Subscriber 观察者，继承自Observer，一般使用这个</li>
<li>Subject 即时观察者也是被观察者，适合公共资源共享传递，比如做RxBus时候。<br>观察者与被观察之间是通过subscribe()方法联系起来。与一般的逻辑相反的是，这里是Observable.subscribe(Observer/Subscriber)<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5></li>
<li>建Observable对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;hello RxJava&quot;);</div><div class="line">                subscriber.onNext(&quot;hi&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>2 创建Subscriber<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void onCompleted() &#123;</div><div class="line">            Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onError(Throwable e) &#123;</div><div class="line">            Log.i(TAG, e.getMessage());</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onNext(String s) &#123;</div><div class="line">            Log.i(TAG, s);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>3 两者关联起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(subscriber);</div></pre></td></tr></table></figure></p>
<p>4 运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hello RxJava</div><div class="line">hi</div><div class="line">onCompleted</div></pre></td></tr></table></figure></p>
<h5 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h5><h6 id="Observable，就是一个需要被观察的对象，序列，生成的方式"><a href="#Observable，就是一个需要被观察的对象，序列，生成的方式" class="headerlink" title="Observable，就是一个需要被观察的对象，序列，生成的方式"></a><strong><em>Observable，就是一个需要被观察的对象，序列，生成的方式</em></strong></h6><p>   首先，.Observable是什么东西已经知道了，在RxJava里面，他是最基本的类，1W多行ORZ，创建Observable的方式有很多种</p>
<h6 id="create"><a href="#create" class="headerlink" title="create"></a><strong>create</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable.create(OnSubscribe)</div></pre></td></tr></table></figure>
<p>OnSubcribe是一个了是Listener之类的东西，暂时不管，只是知道他有一个call方法，可以通过该call方法回调Subscriber的onNext，onComplete，onError方法。<br> <img src="http://reactivex.io/documentation/operators/images/create.c.png" alt=""></p>
<h6 id="just"><a href="#just" class="headerlink" title="just"></a><strong>just</strong></h6><p>他可以接收1~9个参数，例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void onCompleted() &#123;</div><div class="line">              Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onError(Throwable e) &#123;</div><div class="line"> </div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onNext(String s) &#123;</div><div class="line">              Log.i(TAG, s);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>他会依次调用Subscriber的onNext，onNext,onComplete/onError，这里会打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line">C</div><div class="line">onCompleted</div></pre></td></tr></table></figure></p>
<p>他的OnSubscribe类型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnSubscribeFromArray--&gt;数组</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/just.png" alt=""></p>
<h6 id="from"><a href="#from" class="headerlink" title="from"></a><strong>from</strong></h6><p>接收一个Iterable对象(集合List)或者是数组对象，或者是一个线程的Future，例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.from(new String[]&#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void call(String s) &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>他的 OnSubscribe类型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OnSubscribeFromIterable --&gt;Iterable</div><div class="line">OnSubscribeFromArray --&gt;数组</div><div class="line">ToObservableFuture --&gt; Future</div></pre></td></tr></table></figure></p>
<p>从这里可以看出，just是最终的实现是调用了from操作符。<br><img src="http://reactivex.io/documentation/operators/images/from.c.png" alt=""></p>
<h6 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a><strong>Defer</strong></h6><p>直到有订阅者倍subscribe的时候才会创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">str = &quot;Hello，RxJava&quot;;</div><div class="line">       Observable&lt;String&gt; observable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;String&gt; call() &#123;</div><div class="line">               return Observable.just(str);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       str = &quot;hi，RxJava&quot;;</div><div class="line">       observable.subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hi，RxJava</div></pre></td></tr></table></figure></p>
<p>当你使用别的操作符去生成observable的时候发现会是“Hello，RxJava”<br>他的OnSubscribe类型是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnSubscribeDefer --&gt; 泛型</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/defer.c.png" alt=""></p>
<h6 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a><strong>Interval</strong></h6><p>固定时间间隔发送整数序列的Observable，类似一个计数器，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> Observable.interval(1, TimeUnit.SECONDS,Schedulers.io()).subscribe(new Action1&lt;Long&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void call(Long aLong) &#123;</div><div class="line">        Log.i(TAG, String.valueOf(aLong));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>需要注意的是：在Android，在UI线程中去使用，需要制定interval的调度器<br>参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//第一个参数是延时多久开始，第二个参数是每隔多久计时，第三个参数是计时类型，比如TimeUnit .SECONDS,TimeUnit.HOURS等，第四个是调度器，其他重载的方法类似</div><div class="line">Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit,Schedulers scheduler)</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/interval.c.png" alt=""></p>
<h6 id="range"><a href="#range" class="headerlink" title="range"></a><strong>range</strong></h6><p>创建一个特定序列的Observable，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 5).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>当然你也可以知道调度器。其中，第一个是start，第二个参数是count，比如例子的意思就是从10开始，生产5个连续的int，就是10,11,12,13,14<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnSubscribeRange --&gt; start ,end</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/range.c.png" alt=""></p>
<h6 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a><strong>repeat</strong></h6><p>重复发送使用一个Observable，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 2).repeat(4).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>他默认是在一个新线程去运行的，需要注意的是repeat不是一个static方法，他是操作在一个Observable之上的。<br><img src="http://reactivex.io/documentation/operators/images/repeat.c.png" alt=""></p>
<h6 id="timer"><a href="#timer" class="headerlink" title="timer"></a><strong>timer</strong></h6><p>用于延迟多久之后开始某动作，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.timer(2,TimeUnit.SECONDS, Schedulers.newThread()).subscribe(new Action1&lt;Long&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void call(Long aLong) &#123;</div><div class="line">            Log.i(TAG, aLong.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/timer.c.png" alt=""></p>
<h6 id="empty-never-error"><a href="#empty-never-error" class="headerlink" title="empty ,never,error"></a><strong>empty</strong> ,<strong>never</strong>,<strong>error</strong></h6><p>用来处理特殊情况的Observable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable.empty(); //用来发送不发射任何数据的但是正常结束的Observable</div><div class="line">Observable.never();// 不发射数据也不终止</div><div class="line">Observable.error(new Throwable());// 发射一个错误</div></pre></td></tr></table></figure></p>
<p>他的使用就是你需要返回一个Observable对象，但是这个对象又不能为空，又不能去处理事情的时候就可以使用。<br><img src="http://reactivex.io/documentation/operators/images/empty.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/never.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/throw.c.png" alt=""></p>
<h5 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h5><h6 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h6><p>转换对象的时候使用，就是把一个Observable装换为另外一个Observable，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;).map(new Func1&lt;String, Integer&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public Integer call(String s) &#123;</div><div class="line">           return s.hashCode();</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public void call(Integer integer) &#123;</div><div class="line"> </div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>从这个例子我们就可以看出，这里是把一个关于String的Observable变换为了一个关于Integer的Observable，最后让被观察者得到。<br>map适合的范围是1对1的装换，不适合一对多的装换。</p>
<h6 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h6><p>一对多的转换，他的一版使用场景就是，比如去除for循环(map也行)，比如需要把从一个对象去除它包含的List子对象然后迭代等，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">一个对象A中，包含了一个List&lt;B\&gt; ，现在需要取出B</div></pre></td></tr></table></figure></p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.just(test).flatMap(new Func1&lt;Test, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;String&gt; call(Test test) &#123;</div><div class="line">                return Observable.from(test.list);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s+&quot;---FlatMap&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>使用Map是暂时无法做到这一点的，除非是在call内部使用一个for循环去做。<br>flatMap的图是：<br><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt=""></p>
<h6 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a><strong>concatMap</strong></h6><p>一个输出有序的Observable，他的用户跟flatMap差不多，只是，他是会按照顺序输出，flatMap不一定，这种情况是在你需要返回一个Observable<t>对象的时候，他是通过异步去获取的，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.from(test.list).flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public Observable&lt;String&gt; call(String str) &#123;</div><div class="line">              return Observable.just(str).subscribeOn(Schedulers.from(Executors.newFixedThreadPool(1)));</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(String s) &#123;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></t></p>
<p>使用flatMap的话并不一定能保证顺序。在测试过程发现假如把Schedulers.from(Executors.newFixedThreadPool(1))替换为Schedulers.io()或者是Schedulers.newThread()等是顺序不会变的，目前还不知道为什么，就是使用自定义的线程池的时候会。<br><img src="http://reactivex.io/documentation/operators/images/concatMap.png" alt=""></p>
<h6 id="swichMap"><a href="#swichMap" class="headerlink" title="swichMap"></a><strong>swichMap</strong></h6><p> 同样是跟flatMap很类似，除了有一点，就是在异步环境下，当旧数据订阅没有完成，switchMap取消订阅和停止监视那个数据项产生的的Observable，比如下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.from(test.list).switchMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;String&gt; call(String s) &#123;</div><div class="line">                return Observable.just(s).subscribeOn(Schedulers.newThread());</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>被监视的Observable是否取消决定于他是否已经被观察者得到，假如得到的话观察者是能看到这个值的，但是假如他没有被观察者得到，就会被取消订阅，并且不在被观察。<br>上面那个假如是写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Observable.from(test.list).switchMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public Observable&lt;String&gt; call(String s) &#123;</div><div class="line">           try &#123;</div><div class="line">               Thread.sleep(2000);</div><div class="line">           &#125; catch (InterruptedException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line">           return Observable.just(s).subscribeOn(Schedulers.newThread());</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public void call(String s) &#123;</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>就会得到所有的输出。<br><img src="http://reactivex.io/documentation/operators/images/switchMap.png" alt=""></p>
<h6 id="case"><a href="#case" class="headerlink" title="case"></a><strong>case</strong></h6><p>转换操作符，他是强制制定类型的装换，没有map那么灵活，而且，当不能装换的时候，会爆出ClassCastException，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">Observable.just(&quot;A&quot;).cast(String.class).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void call(String String) &#123;</div><div class="line">        Log.i(TAG,String);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/cast.png" alt=""></p>
<h6 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a><strong>groupBy</strong></h6><p>分组 就是按照一种类型的key分组，例子如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).groupBy(new Func1&lt;Integer, Integer&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public Integer call(Integer integer) &#123;</div><div class="line">          //制定某种规则，这里是分为了三种</div><div class="line">              return integer % 3;</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(GroupedObservable&lt;Integer, Integer&gt; stringIntegerGroupedObservable) &#123;</div><div class="line">              stringIntegerGroupedObservable.subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">                  @Override</div><div class="line">                  public void call(Integer integer) &#123;</div><div class="line">                      Log.i(TAG, stringIntegerGroupedObservable.getKey() + &quot;====&quot; +integer.toString());</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 1====10</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 2====11</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 0====12</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 1====13</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 2====14</div><div class="line">08-31 23:54:55.437 17504-17504/com.example.user.testproject I/RxJavaTest: 0====15</div></pre></td></tr></table></figure></p>
<p>再比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;AB&quot;,&quot;C&quot;,&quot;D&quot;).groupBy(new Func1&lt;String,Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(String s) &#123;</div><div class="line">               return s.contains(&quot;A&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;GroupedObservable&lt;Boolean, String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(GroupedObservable&lt;Boolean, String&gt; stringGroupedObservable) &#123;</div><div class="line">               stringGroupedObservable.subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public void call(String s) &#123;</div><div class="line">                       Log.i(TAG, stringGroupedObservable.getKey() + &quot;====&quot; +s.toString());</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: true====A</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: true====A</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: false====B</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: true====AB</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: false====C</div><div class="line">08-31 23:53:14.357 16194-16194/com.example.user.testproject I/RxJavaTest: false====D</div></pre></td></tr></table></figure></p>
<p>其中stringGroupedObservable.getKey()是获得分组的依据的表示，之后的那个是值。<br><img src="http://reactivex.io/documentation/operators/images/groupBy.c.png" alt=""></p>
<h6 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a><strong>Scan</strong></h6><p>他的作用是连续对数据序列的每一项应用一个func，然后连续发射结果。例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,2).scan(new Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Integer call(Integer integer, Integer integer2) &#123;</div><div class="line">               Log.i(TAG, integer +&quot;===&quot;+integer2);</div><div class="line">               return integer+integer2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;Subacriber&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">09-01 21:40:45.112 22400-22400/com.example.user.testproject I/RxJavaTest: 10Subacriber</div><div class="line">09-01 21:40:45.112 22400-22400/com.example.user.testproject I/RxJavaTest: 10===11</div><div class="line">09-01 21:40:45.112 22400-22400/com.example.user.testproject I/RxJavaTest: 21Subacriber</div></pre></td></tr></table></figure></p>
<p>他的第一个值是不参与func2的操作，当然你也可以传递一个init值进入作为默认操作。他的第一个参数是上一次计算的结果传入，第二个参数是被观察的序列值，从2开始，第三个是返回类型，三者是类型一样的。使用一个默认的种子计算的，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 2).scan(&quot;A&quot;, new Func2&lt;String, Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(String s, Integer integer) &#123;</div><div class="line">               Log.i(TAG, s + &quot;==&quot; + integer);</div><div class="line">               return s + integer;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A==10</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A10</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A10==11</div><div class="line">09-01 21:44:51.572 27312-27312/? I/RxJavaTest: A1011</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/scan.c.png" alt=""></p>
<h6 id="flatMapIterable"><a href="#flatMapIterable" class="headerlink" title="flatMapIterable"></a><strong>flatMapIterable</strong></h6><p>他的作用是处理一些复杂的数据，接受一个Observable之后，返回一个Iterable，然后，这个Iterable会依次的传递给下面一层或者是Observer，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        list.add(&quot;A&quot;);</div><div class="line">        list.add(&quot;E&quot;);</div><div class="line">        list.add(&quot;K&quot;);</div><div class="line">        Observable.from(list).flatMapIterable(new Func1&lt;String, Iterable&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Iterable&lt;Integer&gt; call(String s) &#123;</div><div class="line">                return getIntegers(s);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            private Iterable&lt;Integer&gt; getIntegers(String s) &#123;</div><div class="line">                List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</div><div class="line">                integers.add((int) s.charAt(0)+1);</div><div class="line">                integers.add(s.charAt(0)+2);</div><div class="line">                return integers;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer +&quot;==flatMapIterable&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 66==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 67==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 70==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 71==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 76==flatMapIterable</div><div class="line">09-01 22:05:35.582 19199-19199/com.example.user.testproject I/RxJavaTest: 77==flatMapIterable</div></pre></td></tr></table></figure></p>
<h6 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a><strong>buffer</strong></h6><p>该操作符的作用是先计算一定量的结果，之后再去回调结果给下一个Observable或者是Observer，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;).buffer(2).subscribe(new Action1&lt;List&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(List&lt;String&gt; strings) &#123;</div><div class="line">               Log.i(TAG, strings +&quot;==flatMapIterable&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果就是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">09-01 22:10:41.272 24829-24829/com.example.user.testproject I/RxJavaTest: [A, B]==flatMapIterable</div><div class="line">09-01 22:10:41.272 24829-24829/com.example.user.testproject I/RxJavaTest: [C]==flatMapIterable</div></pre></td></tr></table></figure></p>
<p>这个方法是按照顺序不重复，当然他还有很多重载的操作，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">buffer(int count, int skip) // 一次缓存几个，之后每次跳过几个，按照顺序，重复，每次剔除最前面的</div><div class="line">buffer(long timespan, long timeshift, TimeUnit unit)</div><div class="line">buffer(long timespan, TimeUnit unit)// 每个多久，取出数据</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/Buffer.png" alt=""></p>
<h6 id="window"><a href="#window" class="headerlink" title="window"></a><strong>window</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h5 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h5><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h6><p>符合某种规则的Observable才会向下传递，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.range(100,10).filter(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public Boolean call(Integer integer) &#123;</div><div class="line">           return integer&gt;105;</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">       @Override</div><div class="line">       public void call(Integer integer) &#123;</div><div class="line"> </div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.c.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/filter.png" alt=""><br>上面的Subscriber只会得到大于105的数值</p>
<h6 id="first"><a href="#first" class="headerlink" title="first"></a><strong>first</strong></h6><p>只发射第一项，或者是满足条件的第一项，两个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.range(100,5).first();// 发射100</div><div class="line">Observable.range(100,5).first(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public Boolean call(Integer integer) &#123;</div><div class="line">        return integer&gt;102;//发射103</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.c.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/first.png" alt=""></p>
<h6 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a><strong>Debounce</strong></h6><p>当操作太频繁的时候，在第N个节点发射之前会忽略钱N-1个节点，比如我们的Edittext去seach的时候，可能需要过滤前多少秒的操作只是需要后续的操作。简单点来说，就是，他需要的是在某个时间点之后的结果，在这个时间点之前的结果他会忽略不再发送给下一级。例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</div><div class="line">               try &#123;</div><div class="line">                   for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line">                       subscriber.onNext(i);</div><div class="line">                       Thread.sleep(100*i);</div><div class="line">                   &#125;</div><div class="line">                   subscriber.onCompleted();</div><div class="line">               &#125; catch (InterruptedException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">                   subscriber.onError(e);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribeOn(Schedulers.newThread())</div><div class="line">               .debounce(500, TimeUnit.MILLISECONDS).subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;OnComplete&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;Throwable&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(Integer integer) &#123;</div><div class="line">               Log.i(TAG, &quot;integer == &quot;+integer.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出就是6.7.8.9.10<br>总结就是debounce操作符就是类似一个控制入口，他是有一个门卡的，门卡一般是时间，在这之前的忽略，之后的可以进入<br>例子是来自<a href="http://blog.csdn.net/job_hesc/article/details/46495281" target="_blank" rel="external"> Android RxJava使用介绍（三） RxJava的操作符</a><br>其中，还有一个throttleWithTimeout操作符，他的底层也是通过调用debounce操作符完成的，作用类似。但是debounce比她在、多了一个功能就是可以通过函数来进行限流操作。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.just(1, 2, 3, 4, 5).debounce(new Func1&lt;Integer, Observable&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Integer&gt; call(Integer integer) &#123;</div><div class="line">                return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</div><div class="line">                        if (integer % 2 == 0 &amp;&amp; !subscriber.isUnsubscribed()) &#123;</div><div class="line">                            subscriber.onNext(integer);</div><div class="line">                            subscriber.onCompleted();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(Integer integer) &#123;</div><div class="line">                        Log.i(TAG, integer.toString() + &quot;==integer&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>结果输出是2.4.5。5为什么在其中？因为，在debounce操作符中，最后一个Observable，在被调用onComplete之前的时间间隔内被调用，那么他也会被传递到下一级。<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.c.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/debounce.f.png" alt=""></p>
<h6 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a><strong>Distinct</strong></h6><p>只允许没有发射过的数据发射，可以定义过滤规则，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.range(1,5).distinct(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public String call(Integer integer) &#123;</div><div class="line">              if(integer&lt;=2) return &quot;1&quot;;// 定义过滤规则</div><div class="line">              return &quot;2&quot;;</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Integer integer) &#123;</div><div class="line">              Log.i(TAG, integer.toString());</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      Observable.just(1,2,3,1,2).distinct().subscribe(new Action1&lt;Integer&gt;() &#123; // 使用默认规则</div><div class="line">          @Override</div><div class="line">          public void call(Integer integer) &#123;</div><div class="line">              Log.i(TAG, integer.toString());</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 1==自定义</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 3==自定义</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 1===系统</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 2===系统</div><div class="line">09-02 00:32:45.009 4762-4762/? I/RxJavaTest: 3===系统</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/distinct.key.png" alt=""></p>
<h6 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a><strong>elementAt</strong></h6><p>某一位置的元素可以发射，需要需要越界的问题，他是从0开始计算的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).elementAt(9).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/elementAt.png" alt=""></p>
<h6 id="last"><a href="#last" class="headerlink" title="last"></a><strong>last</strong></h6><p>最后一个或者满足条件的最后一个，跟first相反，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,5).last();</div><div class="line">        Observable.range(10,5).last(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(Integer integer) &#123;</div><div class="line">                return integer&gt;13;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString()+&quot;===last&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h6 id="skip"><a href="#skip" class="headerlink" title="skip"></a><strong>skip</strong></h6><p>跳过前N项，从第N+1开始发射，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,20).skip(10);</div></pre></td></tr></table></figure></p>
<p>这个例子是丢弃了10~29中的10~19，保留20~29，还有两个重载的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">skip(long,TimeUnit));// 跳过前long时间的Observable，发射之后的</div><div class="line">skip(long,TimeUnit,Scheduler));//可以定义调度器</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skip.png" alt=""><br>结果是14，两个都是<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.png" alt=""><br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png" alt=""></p>
<h6 id="skipLast"><a href="#skipLast" class="headerlink" title="skipLast"></a><strong>skipLast</strong></h6><p>不发射后n项数据，跟skip相反，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(1,10).skipLast(3).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Integer integer) &#123;</div><div class="line">              Log.i(TAG, integer.toString() + &quot;==skip&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：1,2,3,4,5,6,7<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/skipLast.c.png" alt=""></p>
<h6 id="take"><a href="#take" class="headerlink" title="take"></a><strong>take</strong></h6><p>只取前n项数据，例如有10项数据，那么take(4)，就是只是圈前4项数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).take(5).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString() + &quot;==take&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：10,11，12,13,14<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/take.c.png" alt=""></p>
<h6 id="taskLast"><a href="#taskLast" class="headerlink" title="taskLast"></a><strong>taskLast</strong></h6><p>只发射最后n项数据，比如有10项数据，taskLast(3)，则是只发射最后3项数据，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(9,5).takeLast(2).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public void call(Integer integer) &#123;</div><div class="line">            Log.i(TAG, integer.toString() + &quot;==integer&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：12和13<br>需要注意的是他是一个线程同步的，他可能造成Observable发射延迟，因为他只有过滤掉前面的数据才会轮到后面，然后后面的数据才会发射。<br>重构的方法有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">takeLast(final int count)  //发射后面n个数据，n大于数据全部的时候则发射全部n小于0报异常</div><div class="line">takeLast(int count, long time, TimeUnit unit)// 发射最后给定时间的n个数据</div><div class="line">takeLast(int count, long time, TimeUnit unit, Scheduler scheduler)</div><div class="line">takeLast(long time, TimeUnit unit, Scheduler scheduler)//发射最后给定时间的全部数据，可以指定调度器</div><div class="line">takeLast(long time, TimeUnit unit)</div></pre></td></tr></table></figure></p>
<p>同时，他还有一个变形，<em>takeLastBuffer*</em>，takeLast是一个一个数据源返回，但是takeLastBuffer是以List的形式返回，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(20,10).takeLastBuffer(5).subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(List&lt;Integer&gt; integers) &#123;</div><div class="line">              Log.i(TAG, integers.toString() + &quot;==integer&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/takeLast.c.png" alt=""></p>
<h6 id="ignoreElements"><a href="#ignoreElements" class="headerlink" title="ignoreElements"></a><strong>ignoreElements</strong></h6><p>忽略所有的元素，只是发射结束事件或者是错误时间，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).ignoreElements().subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot;);</div><div class="line">           &#125;</div><div class="line">           @Override</div><div class="line">           public void onNext(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString() + &quot;==ignoreElements&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/ignoreElements.c.png" alt=""></p>
<h6 id="last-1"><a href="#last-1" class="headerlink" title="last"></a><strong>last</strong></h6><p>只发射最后的一项数据，忽略前面n项数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).last().subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer.toString() + &quot;==last&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：19<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.c.png" alt=""><br>还有一个last(Func1)的重载函数，他可以规定那个才是last，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).last(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString() + &quot;==last&quot;);</div><div class="line">                return integer == 14;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, integer.toString() + &quot;==last func&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>在subscribe里面输出的就是14而不是19，还有一个相似函数是:lastOrDefault(T)，他会在Observable没有发射任何数据的时候发射默认值T。<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/last.p.png" alt=""></p>
<h6 id="sample操作符"><a href="#sample操作符" class="headerlink" title="sample操作符"></a><strong>sample</strong>操作符</h6><p>他是在某一段时间内采集过去发射的旧数据再次发射，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.interval(1,TimeUnit.SECONDS).sample(2,TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Long aLong) &#123;</div><div class="line">              Log.i(TAG, aLong.toString() + &quot;==sample &quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>interval创造一个Observable之后每个1s发射一个新数据，然后sample会在2s重复的去采集已经发射的旧数据再次发射，输出的结果是:0,2,4,6…<br>它默认kaiq新线程，我们也可指线程给sample运行<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/sample.c.png" alt=""></p>
<p>使用</p>
<h5 id="结合操作符"><a href="#结合操作符" class="headerlink" title="结合操作符"></a>结合操作符</h5><p>组合操作符的作用是可以结合多个Observable进行操作。</p>
<h6 id="CombineLatest-操作符"><a href="#CombineLatest-操作符" class="headerlink" title="CombineLatest 操作符"></a><strong>CombineLatest</strong> 操作符</h6><p>他可以组合两个Observable，进行一定的操作之后，再次发射下去，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.combineLatest(Observable.range(5,2), Observable.range(10, 4), new Func2&lt;Integer, Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer, Integer integer2) &#123;</div><div class="line">               return integer+&quot;==&quot;+integer2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s + &quot;=combineLatest&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==10=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==11=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==12=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==13=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==14=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==15=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==16=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==17=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==18=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==19=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==20=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==21=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==22=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==23=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==24=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==25=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==26=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==27=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==28=combineLatest</div><div class="line">10-19 15:31:45.776 20501-20501/com.example.user.testproject I/RxJavaTest: 6==29=combineLatest</div></pre></td></tr></table></figure></p>
<p>它继续发射的前提是：其中的一个Observable还有数据没有发射，那么，他讲两个Observable目前最新发射的数据组合在一起，比如上面，第一个Observable最新的数据是6，然后第二个的依次在变，然后再把他们组合在一起。<br>重载方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">combineLatest(List&lt;? extends Observable&lt;? extends T&gt;&gt; sources, FuncN&lt;? extends R&gt; combineFunction)</div><div class="line">或者是：</div><div class="line">combineLatest(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources, FuncN&lt;? extends R&gt; combineFunction)</div></pre></td></tr></table></figure></p>
<p>他们都是输入一堆的List<observable<t>&gt;类型的数据或者是Iterable数据，然后通过可变参数进行处理，适合需要多个Observable进行拼接，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">List&lt;Observable&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">       list.add(A.range(10, 1));</div><div class="line">       list.add(A.range(10, 1));</div><div class="line">       list.add(A.range(10, 1));</div><div class="line">       Observable.combineLatest(list, new FuncN&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Object call(Object... args) &#123;</div><div class="line">               for (Object obj : args) &#123;</div><div class="line">                   Log.i(TAG, obj.toString());</div><div class="line">               &#125;</div><div class="line">               return args;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Object o) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></observable<t></p>
<p><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/combineLatest.c.png" alt=""></p>
<h6 id="join组合操作符"><a href="#join组合操作符" class="headerlink" title="join组合操作符"></a><strong>join</strong>组合操作符</h6><p>他的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final &lt;TRight, TLeftDuration, TRightDuration, R&gt; Observable&lt;R&gt; join(Observable&lt;TRight&gt; right, Func1&lt;T, Observable&lt;TLeftDuration&gt;&gt; leftDurationSelector,</div><div class="line">            Func1&lt;TRight, Observable&lt;TRightDuration&gt;&gt; rightDurationSelector,</div><div class="line">            Func2&lt;T, TRight, R&gt; resultSelector)</div></pre></td></tr></table></figure></p>
<p>例子调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; left =</div><div class="line">                Observable.interval(100, TimeUnit.MILLISECONDS)</div><div class="line">                        .map(new Func1&lt;Long, String&gt;() &#123;</div><div class="line">                            @Override</div><div class="line">                            public String call(Long aLong) &#123;</div><div class="line">                                return &quot;L&quot; + aLong;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">        Observable&lt;String&gt; right =</div><div class="line">                Observable.interval(200, TimeUnit.MILLISECONDS)</div><div class="line">                        .map(new Func1&lt;Long, String&gt;() &#123;</div><div class="line">                            @Override</div><div class="line">                            public String call(Long aLong) &#123;</div><div class="line">                                return &quot;R&quot; + aLong;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">        left.join(right, new Func1&lt;String, Observable&lt;Integer&gt;&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Observable&lt;Integer&gt; call(String s) &#123;</div><div class="line">                        Log.i(TAG, s + &quot;==&quot;);</div><div class="line">                        return Observable.never();</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Observable&lt;Long&gt; call(String s) &#123;</div><div class="line">                        Log.i(TAG, s + &quot;=====&quot;);</div><div class="line">                        return Observable.timer(0, TimeUnit.MILLISECONDS);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                , new Func2&lt;String, String, String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public String call(String s, String s2) &#123;</div><div class="line">                        return s + &quot;-&quot; + s2;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .take(10)</div><div class="line">                .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(String s) &#123;</div><div class="line">                        Log.i(TAG, s);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>例子来源：<a href="http://blog.chengyunfeng.com/?p=980&amp;utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">RxJava 教程第四部分：并发 之意外情况处理</a><br>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">L0==</div><div class="line">L1==</div><div class="line">R0=====</div><div class="line">L1-R0</div><div class="line">L0-R0</div><div class="line">L2==</div><div class="line">L3==</div><div class="line"> R1=====</div><div class="line"> L1-R1</div><div class="line">L0-R1</div><div class="line">L3-R1</div><div class="line">L2-R1</div><div class="line">L4==</div><div class="line">R2=====</div><div class="line">L4-R2</div><div class="line">L1-R2</div><div class="line">L0-R2</div><div class="line"> L3-R2</div></pre></td></tr></table></figure></p>
<p>可以看到，在right join如left之后，她会结合每一次left的发射的Observable，然后再次发射，但是他的前提是left窗口还有数据在发射。假如left窗口没有数据了，那么right窗口也就不会再去跟left窗口接口再去发射了，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,10).join(Observable.range(10, 2), new Func1&lt;Integer, Observable&lt;Object&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Object&gt; call(Integer integer) &#123;</div><div class="line">                return Observable.just(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Func1&lt;Integer, Observable&lt;Object&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Object&gt; call(Integer integer) &#123;</div><div class="line">                return Observable.never();</div><div class="line">            &#125;</div><div class="line">        &#125;, new Func2&lt;Integer, Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String call(Integer integer, Integer integer2) &#123;</div><div class="line">                return integer + &quot;-&quot; + integer2;</div><div class="line">            &#125;</div><div class="line">        &#125;).take(10).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s + &quot;join&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>将不会有输出。<br>图：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png" alt=""></p>
<h6 id="merge-组合操作符"><a href="#merge-组合操作符" class="headerlink" title="merge 组合操作符"></a><strong>merge</strong> 组合操作符</h6><p>用于合并多个Observable，他们需要同类型，按照前到后的顺历依次发射所有的Observable例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.merge(Observable.range(10,2),Observable.range(20,3)).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;merge&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 10merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 11merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 20merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 21merge</div><div class="line">10-19 15:47:39.973 2140-2140/? I/RxJavaTest: 22merge</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/join.c.png" alt=""></p>
<h6 id="zip-组合操作符"><a href="#zip-组合操作符" class="headerlink" title="zip 组合操作符"></a><strong>zip</strong> 组合操作符</h6><p>用于多两个Observable进行再次操作之后再次发射，他是有顺序的，他会按照顺序去结合多个Observable之间的数据，按照最短的数据为zip的func2的调用次数，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.zip(Observable.range(10, 10), Observable.range(5, 2), new Func2&lt;Integer, Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer, Integer integer2) &#123;</div><div class="line">               return integer+&quot;-&quot;+integer2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG,s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10-19 15:57:57.482 11123-11123/com.example.user.testproject I/RxJavaTest: 10-5</div><div class="line">10-19 15:57:57.482 11123-11123/com.example.user.testproject I/RxJavaTest: 11-6</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/zip.o.png" alt=""></p>
<h6 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a><strong>zipWith</strong></h6><p>跟zip类型，但是他是非静态的，需要在另外一个Observable操作之上,他接受两个参数，一种是一个Observable和Func2，另外一个是多个组合， Iterable和Func2例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,2).zipWith(Observable.range(10,1),new Func2&lt;Integer,Integer,String&gt;()&#123;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public String call(Integer o, Integer o2) &#123;</div><div class="line">               return o+&quot;=&quot;+o2;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG,s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://reactivex.io/documentation/operators/images/zip.i.png" alt=""></p>
<h6 id="switchOnNext"><a href="#switchOnNext" class="headerlink" title="switchOnNext"></a><strong>switchOnNext</strong></h6><p>将一个发射多个Observable对象装换为一个Observable发射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.switchOnNext(Observable.just(Observable.range(1,1),Observable.range(2,1))).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;switchOnNext&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">10-19 16:13:26.296 24641-24641/? I/RxJavaTest: 1switchOnNext</div><div class="line">10-19 16:13:26.296 24641-24641/? I/RxJavaTest: 2switchOnNext</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/switch.c.png" alt=""></p>
<h6 id="startWith"><a href="#startWith" class="headerlink" title="startWith"></a><strong>startWith</strong></h6><p>在源Observable之前插入一个或者是多个数据，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(5,2).startWith(6).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Integer integer) &#123;</div><div class="line">               Log.i(TAG, integer + &quot;switchOnNext&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10-19 16:16:10.690 27055-27055/? I/RxJavaTest: 6switchOnNext</div><div class="line">10-19 16:16:10.690 27055-27055/? I/RxJavaTest: 5switchOnNext</div><div class="line">10-19 16:16:10.690 27055-27055/? I/RxJavaTest: 6switchOnNext</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/startWith.png" alt=""></p>
<h5 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h5><p>错误处理操作符主要是在Observable的onError中拦截，做一些事情。</p>
<h6 id="catch操作符"><a href="#catch操作符" class="headerlink" title="catch操作符"></a>catch操作符</h6><p>1  <strong>onErrorReturn</strong> 让Observable遇到错误时候发生一个特殊的数据并且正常终止，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.just(1, 2, 3, 4, 5).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if (integer == 4) &#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;hahaha&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer + &quot;str&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;).onErrorReturn(new Func1&lt;Throwable, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Throwable throwable) &#123;</div><div class="line">               Log.i(TAG, throwable.getMessage());</div><div class="line">               return &quot;Bingo&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;Result == &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == 1str</div><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == 2str</div><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == 3str</div><div class="line">10-26 13:25:46.623 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: hahaha</div><div class="line">10-26 13:25:46.633 19493-19493/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: Result == Bingo</div></pre></td></tr></table></figure></p>
<p>说明：onErrorReturn操作符他会拦截错误，然后在拦截错误之后，不再继续发射源Observable的数据，同时，他将在Func1中返回一个对应的可被观测的数据传递到onNext中，然后调用了onComplete方法完成这一次的Observable过程。</p>
<p>2  <strong>onErrorResumeNext</strong> 让Observable遇到错误时开始发射第二个Observable数据序列，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.just(1, 2, 3, 4, 5).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if (integer == 4) &#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;hahaha&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer + &quot;str&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"> observable.onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;? extends String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;? extends String&gt; call(Throwable throwable) &#123;</div><div class="line">               return Observable.just(&quot;Bingo&quot;,&quot;Hello&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;onErrorResumeNext == &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == 1str</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == 2str</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == 3str</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == Bingo</div><div class="line">10-26 13:40:56.843 5987-5987/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorResumeNext == Hello</div></pre></td></tr></table></figure></p>
<p>可以看到他是终止了继续发射，但是他可以补充发射，就是在遇到错误的时候，可以在源Observable基础上面继续发射多个Observable直到结束。<br>他的重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; onErrorResumeNext(final Observable&lt;? extends T&gt; resumeSequence)</div></pre></td></tr></table></figure></p>
<p>使用也是类似，他也是可以在遇到错误之后发射多个Observable。</p>
<p>3  <strong>onExceptionResumeNext</strong> 让Observable遇到错误时发射继续发射后面的数据项，例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.just(1, 2, 3, 4, 5).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if (integer == 4) &#123;</div><div class="line">                   throw new Error(&quot;hahaha&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer + &quot;str&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"> observable.onExceptionResumeNext(Observable.just(&quot;A&quot;, &quot;B&quot;)).subscribe(new Observer&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot;+e.getMessage());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;onNext&quot;+s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-26 13:49:21.803 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext1str</div><div class="line">10-26 13:49:21.803 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext2str</div><div class="line">10-26 13:49:21.803 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext3str</div><div class="line">10-26 13:49:21.813 16041-16041/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onErrorhahaha</div></pre></td></tr></table></figure></p>
<p>加入不是抛出Error，而是Exception的子类的时候，则结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext1str</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext2str</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNext3str</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNextA</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onNextB</div><div class="line">10-26 13:50:57.643 17881-17881/fortunetelling.mmc.oms.rxjavademo I/MainActivityLOG: onCompleted</div></pre></td></tr></table></figure></p>
<p>说明onExceptionResumeNext操作符是在上级源Observable出现的是Exception的子类的时候调用他自己的Observable继续发射下去，同时是不回再去发射源Observable的数据。但是假如上级源Observable出现的不是Exception的子类的时候，那么他会直接调用onError方法结束发射。<br>对应的图：<br>onErrorReturn：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorReturn.png" alt=""><br>onErrorResumeNext：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onErrorResumeNext.png" alt=""><br>onExceptionResumeNext：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/onExceptionResumeNextViaObservable.png" alt=""></p>
<h6 id="retry操作符"><a href="#retry操作符" class="headerlink" title="retry操作符"></a>retry操作符</h6><p>retry操作符不会把错误传递到Observer的onError当中去。他可以不停的retry，尝试能够让源Observable正常发射结束。<br>1 <strong>retry</strong> 操作符，他会在源Observable在发生error的时候不断的重新去调用源数据，重头开始发射，存在了数据可能重复的结果，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if(integer == 11)&#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer.toString() + &quot;retry&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.retry().subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是不断的打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10retry</div></pre></td></tr></table></figure></p>
<p>重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; retry(final long count)</div></pre></td></tr></table></figure></p>
<p>他可以设置重试次数，超出重试次数之后任然发生错误，那么他将会调用onError方法，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if(integer == 11)&#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer.toString() + &quot;retry&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.retry(2).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Throwable throwable) &#123;</div><div class="line">               Log.i(TAG, throwable.getMessage());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-26 14:22:50.137 4099-4099/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:22:50.138 4099-4099/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:22:50.138 4099-4099/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:22:50.138 4099-4099/com.example.user.testproject I/RxJavaTest: exception</div></pre></td></tr></table></figure></p>
<p>重载函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">retry(Func2&lt;Integer, Throwable, Boolean&gt; predicate)</div></pre></td></tr></table></figure></p>
<p>他可以设定某种界限，在不超出某个条件之下不断的重试，或者说只要是返回了true都会重试，反之停止，停止之后还是发生了错误，就会调用onError方法，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(Integer integer) &#123;</div><div class="line">               if(integer == 11)&#123;</div><div class="line">                   throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">               &#125;</div><div class="line">               return integer.toString() + &quot;retry&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.retry(new Func2&lt;Integer, Throwable, Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(Integer integer, Throwable throwable) &#123;</div><div class="line">               return integer&lt;3;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, s);</div><div class="line">           &#125;</div><div class="line">       &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Throwable throwable) &#123;</div><div class="line">               Log.i(TAG, throwable.getMessage());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>他的意思是，在重试次数少于3的时候就会重试，否则就不会，输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-26 14:28:34.882 8577-8577/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:28:34.883 8577-8577/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:28:34.883 8577-8577/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 14:28:34.883 8577-8577/com.example.user.testproject I/RxJavaTest: exception</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="https://mcxiaoke.gitbooks.io/rxdocs/content/images/operators/retry.C.png" alt=""></p>
<ol>
<li><strong>retryWhen</strong> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.range(10, 3).map(new Func1&lt;Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String call(Integer integer) &#123;</div><div class="line">                if(integer == 11)&#123;</div><div class="line">                    throw new IllegalArgumentException(&quot;exception&quot;);</div><div class="line">                &#125;</div><div class="line">                return integer.toString() + &quot;retry&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        observable.retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; observable) &#123;</div><div class="line">               return observable.zipWith(Observable.range(1, 3), new Func2&lt;Throwable, Integer, Object&gt;() &#123;</div><div class="line">                   @Override</div><div class="line">                   public Object call(Throwable throwable, Integer integer) &#123;</div><div class="line">                       return &quot;123&quot;;</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10-26 15:06:44.358 26227-26227/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 15:06:44.359 26227-26227/com.example.user.testproject I/RxJavaTest: 10retry</div><div class="line">10-26 15:06:44.359 26227-26227/com.example.user.testproject I/RxJavaTest: 10retry</div></pre></td></tr></table></figure></p>
<p>说明:这里使用了zipWith限制了retryWhen的次数，当超出了三次之后，zipWith回隐式的调用onComplete方法，所以这里的Observer的onError方法并不会被调用。<br> 例子来源：<a href="http://www.jianshu.com/p/023a5f60e6d0" target="_blank" rel="external">【译】对RxJava中.repeatWhen()和.retryWhen()操作符的思考</a><br>关于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; retryWhen(final Func1&lt;? super Observable&lt;? extends Throwable&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler)</div></pre></td></tr></table></figure></p>
<p>中的notificationHandler的Observable返回说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">– 如果返回的 Observable 发射了一个数据，retryWhen 将会执行重试操作</div><div class="line">– 如果返回的 Observable 发射了一个错误信息，retryWhen 将会发射一个错误并不会重试</div><div class="line">– 如果返回的 Observable 正常结束了，retryWhen 也正常结束。</div></pre></td></tr></table></figure></p>
<p>出处：<a href="http://blog.chengyunfeng.com/?p=970" target="_blank" rel="external">RxJava 教程第三部分：驯服数据流之 高级错误处理</a><br>也就是说，其实retryWhen的Func1返回的Observable的值并不重要，是他的类型重要，他只是判断是否可以继续执行retryWhen，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; source = Observable.create(o -&gt; &#123;</div><div class="line">    o.onNext(1);</div><div class="line">    o.onNext(2);</div><div class="line">    o.onError(new Exception(&quot;Failed&quot;));</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">source.retryWhen((o) -&gt; o</div><div class="line">        .take(2)</div><div class="line">        .delay(100, TimeUnit.MILLISECONDS))</div><div class="line">    .timeInterval()</div><div class="line">    .subscribe(</div><div class="line">        System.out::println,</div><div class="line">        System.out::println);</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TimeInterval [intervalInMilliseconds=21, value=1]</div><div class="line">TimeInterval [intervalInMilliseconds=0, value=2]</div><div class="line">TimeInterval [intervalInMilliseconds=104, value=1]</div><div class="line">TimeInterval [intervalInMilliseconds=0, value=2]</div><div class="line">TimeInterval [intervalInMilliseconds=103, value=1]</div><div class="line">TimeInterval [intervalInMilliseconds=0, value=2]</div></pre></td></tr></table></figure></p>
<p>出处：<a href="http://blog.chengyunfeng.com/?p=970" target="_blank" rel="external">RxJava 教程第三部分：驯服数据流之 高级错误处理</a><br>他还有一个重载的操作符可以指定调度器Scheduler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; retryWhen(final Func1&lt;? super Observable&lt;? extends Throwable&gt;, ? extends Observable&lt;?&gt;&gt; notificationHandler, Scheduler scheduler)</div></pre></td></tr></table></figure></p>
<h5 id="辅助操作符"><a href="#辅助操作符" class="headerlink" title="辅助操作符"></a>辅助操作符</h5><p>RxJava提供很多的辅助操作符，帮助我们更好的堆Observable进行更加方便的操作。</p>
<h6 id="meterailize-Dematerialize-操作符"><a href="#meterailize-Dematerialize-操作符" class="headerlink" title="meterailize/Dematerialize 操作符"></a><strong>meterailize/Dematerialize</strong> 操作符</h6><p>meterailize操作符被一个合法有限的Observable调用的时候，如果Observable调用Observer的onNext次数为0或者多次，omComplete次数为1次，或者onError1次。meterailize会将不管是onNext还是onComplete还是onError包装成为Observable发射，而Dematerialize的作用则是相反。meterailize使用的时候他会包装Observable的数据源为一个Notification<t>类型再去传递，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,3).map(new Func1&lt;Integer, Notification&lt;Integer&gt;&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public Notification&lt;Integer&gt; call(Integer integer) &#123;</div><div class="line">             return Notification.createOnNext(integer);</div><div class="line">         &#125;</div><div class="line">     &#125;).materialize().subscribe(new Observer&lt;Notification&lt;Notification&lt;Integer&gt;&gt;&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public void onCompleted() &#123;</div><div class="line">             Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">         &#125;</div><div class="line"> </div><div class="line">         @Override</div><div class="line">         public void onError(Throwable e) &#123;</div><div class="line">             Log.i(TAG, &quot;onError&quot;+e.getMessage());</div><div class="line">         &#125;</div><div class="line"> </div><div class="line">         @Override</div><div class="line">         public void onNext(Notification&lt;Notification&lt;Integer&gt;&gt; notification) &#123;</div><div class="line">             Log.i(TAG, &quot;materialize&quot;+notification);</div><div class="line">         &#125;</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></t></p>
<p>输出就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-27 16:35:43.962 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@26788166 OnNext [rx.Notification@133c40b8 OnNext 10]]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@26788167 OnNext [rx.Notification@133c40b9 OnNext 11]]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@26788168 OnNext [rx.Notification@133c40ba OnNext 12]]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: materialize[rx.Notification@df4db0e OnCompleted]</div><div class="line">10-27 16:35:43.963 4606-4606/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>可以看到他是多了一个omCompleted事件的，但是这个传递到onNexu的时候他的值是为null的，所以使用的时候注意。<br>假如是使用Dematerialize操作符，他是把materialize数据源包装的Notification<t>还原回去，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.range(10, 3).map(new Func1&lt;Integer, Notification&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Notification&lt;Integer&gt; call(Integer integer) &#123;</div><div class="line">                return Notification.createOnNext(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;).dematerialize().subscribe(new Subscriber&lt;Object&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(Object notification) &#123;</div><div class="line">                Log.i(TAG, &quot;dematerialize = &quot; + notification);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></t></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10-27 16:42:13.563 10276-10276/? I/RxJavaTest: dematerialize = 10</div><div class="line">10-27 16:42:13.564 10276-10276/? I/RxJavaTest: dematerialize = 11</div><div class="line">10-27 16:42:13.564 10276-10276/? I/RxJavaTest: dematerialize = 12</div><div class="line">10-27 16:42:13.564 10276-10276/? I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>还把最后一个空的过滤了。<br>图片：<br><img src="http://reactivex.io/documentation/operators/images/materialize.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/dematerialize.c.png" alt=""></p>
<h6 id="delay-操作符"><a href="#delay-操作符" class="headerlink" title="delay 操作符"></a><strong>delay</strong> 操作符</h6><p>延迟发射Observable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; delay(long delay, TimeUnit unit)</div></pre></td></tr></table></figure></p>
<p>该方法会延时整一个observable，但是延时结束之后会立马开始发射，之后的数据将不会再延时(同时，以下的其他操作符也是基于这个observable的)例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               Log.i(TAG, &quot;发射&quot;);</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line"></div><div class="line">       observable.delay(2, TimeUnit.SECONDS).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;delay= &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-30 16:12:58.535 3044-3044/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-30 16:13:00.537 3044-3070/com.example.user.testproject I/RxJavaTest: delay= A</div><div class="line">10-30 16:13:00.538 3044-3070/com.example.user.testproject I/RxJavaTest: delay= B</div><div class="line">10-30 16:13:00.538 3044-3070/com.example.user.testproject I/RxJavaTest: delay= C</div><div class="line">10-30 16:13:00.538 3044-3070/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>需要注意的是：<br>当第一个发射的就是onError的时候，该延时将不会起效，立马就会发射给Observer，但是假如是发射onComplete的时候还是会延时的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; Observable&lt;T&gt; delay(Func1&lt;? super T, ? extends Observable&lt;U&gt;&gt; itemDelay)</div></pre></td></tr></table></figure>
<p>他可以给给一个Observable给定一个延时，当Func1返回的Observable发射的时候，源数据对应的数据就会发射，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">observable.delay(2, TimeUnit.SECONDS);</div><div class="line">        observable.delay(new Func1&lt;String, Observable&lt;Integer&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;Integer&gt; call(String s) &#123;</div><div class="line">                if (&quot;A&quot;.equals(s)) &#123;</div><div class="line">                    return Observable.just(1)</div><div class="line">                            .delay(1, TimeUnit.SECONDS);</div><div class="line">                &#125;else &#123;</div><div class="line">                    return Observable.just(1)</div><div class="line">                            .delay(2, TimeUnit.SECONDS);</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;delay= &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>结果“<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-30 16:31:12.929  发射</div><div class="line">10-30 16:31:13.955 delay= A</div><div class="line">10-30 16:31:14.956  delay= B</div><div class="line">10-30 16:31:14.958  delay= C</div><div class="line">10-30 16:31:14.959 onCompleted</div></pre></td></tr></table></figure></p>
<p>这里，A是延时了1s发射，但是其他的数据是延时了约2s发射。注意的是他不是有叠加的效果，不会是让上一个Observable发射了之后再去延时下一个。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/delay.o.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/delay.oo.png" alt=""></p>
<h6 id="delaySubscription-操作符"><a href="#delaySubscription-操作符" class="headerlink" title="delaySubscription 操作符"></a><strong>delaySubscription</strong> 操作符</h6><p>他是延迟Observable中OnSubscribe调用call的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;U&gt; Observable&lt;T&gt; delaySubscription(Func0&lt;? extends Observable&lt;U&gt;&gt; subscriptionDelay)</div></pre></td></tr></table></figure></p>
<p>他根据Func0返回的Observable延迟Observable和Observer之间关联，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">observable.delaySubscription(new Func0&lt;Observable&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;String&gt; call() &#123;</div><div class="line">               Log.i(TAG, &quot;延时订阅开始&quot; );</div><div class="line">               return Observable.just(&quot;A&quot;).delay(2,TimeUnit.SECONDS);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;delaySubscription = &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-30 16:42:28.510 28979-28979/com.example.user.testproject I/RxJavaTest: 延时订阅开始</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: delaySubscription = A</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: delaySubscription = B</div><div class="line">10-30 16:42:30.530 28979-29003/com.example.user.testproject I/RxJavaTest: delaySubscription = C</div></pre></td></tr></table></figure></p>
<p>可以看到延时开始后之后是经过了约2s的时间之后才发生了订阅的关系。<br>重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final Observable&lt;T&gt; delaySubscription(long delay, TimeUnit unit)</div></pre></td></tr></table></figure></p>
<p>该函数的作用也是类似的。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/delaySubscription.o.png" alt=""></p>
<h6 id="do系列操作符"><a href="#do系列操作符" class="headerlink" title="do系列操作符"></a><strong>do</strong>系列操作符</h6><ol>
<li><strong>doOnEach</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnEach(final Action1&lt;Notification&lt;? super T&gt;&gt; onNotification)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>他提供一个Action1的谓词，用于在Observable发射的时候同时也被转换成一个Notification，该Notification中携带了被发射的value，相当于可以多个Observer被调用，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnEach(new Action1&lt;Notification&lt;? super String&gt;&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Notification&lt;? super String&gt; notification) &#123;</div><div class="line">              Log.i(TAG, &quot;notification = &quot; + notification.getValue());</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(String s) &#123;</div><div class="line">              Log.i(TAG, &quot;doOnEach = &quot; + s);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = A</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: doOnEach = A</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = B</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: doOnEach = B</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = C</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: doOnEach = C</div><div class="line">10-31 15:31:40.565 2396-2396/com.example.user.testproject I/RxJavaTest: notification = null</div></pre></td></tr></table></figure></p>
<p>其中最后一个是null代表的onComplete函数被调用。<br>重载函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnEach(Observer&lt;? super T&gt; observer)</div></pre></td></tr></table></figure></p>
<p>他的作用也是类似的，只不过doOnEach参数中的observer的onNext，onComplete,onError也是同样会被调用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">observable.doOnEach(new Observer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot; );</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError = &quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;doOnEach = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: doOnEach = A</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: doOnEach = B</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: doOnEach = C</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:34:05.038 4612-4612/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/doOnEach.png" alt=""></p>
<ol>
<li><strong>doOnNext</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>他的作用只是会回调被发射源数据的onNext函数而不是全部，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnNext(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;doOnNext = &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: doOnNext = A</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: doOnNext = B</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: doOnNext = C</div><div class="line">10-31 15:36:34.501 6801-6801/com.example.user.testproject I/RxJavaTest: subscribe = C</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/doOnNext.png" alt=""></p>
<ol>
<li><strong>doOnSubscribe</strong>操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnSubscribe(final Action0 subscribe)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>操作符注册一个动作，当观察者订阅它生成的Observable它就会被调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnSubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnSubscribe被调用&quot; );</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: doOnSubscribe被调用</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:39:23.039 9254-9254/com.example.user.testproject I/RxJavaTest: subscribe = C</div></pre></td></tr></table></figure></p>
<p>适合做一些在发射数据之前的操作。图：<br><img src="http://reactivex.io/documentation/operators/images/doOnSubscribe.png" alt=""></p>
<ol>
<li><strong>doOnUnsubscribe</strong>操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnUnsubscribe(final Action0 unsubscribe)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当观察者取消订阅它生成的Observable它就会被调用，比如调用了onComplete函数或者是Observer和Observa之间取消了关联的时候被调用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">observable.doOnUnsubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnUnsubscribe&quot; );</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:41:26.559 11057-11057/com.example.user.testproject I/RxJavaTest: doOnUnsubscribe</div></pre></td></tr></table></figure></p>
<p>适合做一些收尾的工作，图：<br><img src="http://reactivex.io/documentation/operators/images/doOnUnsubscribe.png" alt=""></p>
<ol>
<li><strong>doOnCompleted</strong>和<strong>doOnError</strong>操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; doOnCompleted(final Action0 onCompleted)</div><div class="line"> Observable&lt;T&gt; doOnError(final Action1&lt;Throwable&gt; onError)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>会在Observa调用对应的函数之前被调用。注意是之前被调用，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">observable.doOnCompleted(new Action0() &#123;</div><div class="line">          @Override</div><div class="line">          public void call() &#123;</div><div class="line">              Log.i(TAG, &quot;doOnCompleted &quot; );</div><div class="line">          &#125;</div><div class="line">      &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(String s) &#123;</div><div class="line">              Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">          &#125;</div><div class="line">      &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Throwable throwable) &#123;</div><div class="line">              Log.i(TAG, &quot;throwable &quot; + throwable.getMessage());</div><div class="line">          &#125;</div><div class="line">      &#125;, new Action0() &#123;</div><div class="line">          @Override</div><div class="line">          public void call() &#123;</div><div class="line">              Log.i(TAG, &quot;Completed &quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>正常结束的时候结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: doOnCompleted</div><div class="line">10-31 15:47:59.653 16908-16908/com.example.user.testproject I/RxJavaTest: Completed</div></pre></td></tr></table></figure></p>
<p>把observable最后调用改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                Log.i(TAG, &quot;发射&quot;);</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">//                subscriber.onCompleted();</div><div class="line">                subscriber.onError(new IllegalArgumentException(&quot;error&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">  observable.doOnError(new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, &quot;doOnError = &quot; + throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;subscribe = &quot; + s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, &quot;throwable &quot; + throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;Completed &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: subscribe = A</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: subscribe = B</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: subscribe = C</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: doOnError = error</div><div class="line">10-31 15:52:01.173 20513-20513/com.example.user.testproject I/RxJavaTest: throwable error</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/doOnCompleted.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/doOnError.png" alt=""></p>
<ol>
<li><strong>doOnTerminate</strong>操作符<br>在Observable发射终止之前调用，无论是正常还是错误的结束，就是相当于doOnCompleted和doOnError两个的结合体<br>例子就不写了，图：<br><img src="http://reactivex.io/documentation/operators/images/doOnTerminate.png" alt=""></li>
<li><p><strong>doAfterTerminate</strong>操作符<br>在Observable终止之后会被调用，也就是在操作符doOnTerminate之后被调用，在doOnUnsubscribe之后被调用<br>图：<br><img src="http://reactivex.io/documentation/operators/images/doAfterTerminate.png" alt=""></p>
</li>
<li><p><strong>finallyDo</strong>操作符<br>该操作符已经被废弃，但是他的作用是当它产生的Observable终止之后会被调用，无论是正常还是异常终止。会在doOnUnsubscribe操作调用之后调用，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">observable.finallyDo(new Action0() &#123;</div><div class="line">           @Override</div><div class="line">           public void call() &#123;</div><div class="line">               Log.i(TAG, &quot;finallyDo &quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).doOnUnsubscribe(new Action0() &#123;</div><div class="line">           @Override</div><div class="line">           public void call() &#123;</div><div class="line">               Log.i(TAG, &quot;doOnUnsubscribe &quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">10-31 15:58:56.166 26661-26661/com.example.user.testproject I/RxJavaTest: 发射</div><div class="line">10-31 15:58:56.166 26661-26661/com.example.user.testproject I/RxJavaTest: doOnUnsubscribe</div><div class="line">10-31 15:58:56.166 26661-26661/com.example.user.testproject I/RxJavaTest: finallyDo</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/finallyDo.png" alt=""></p>
<h6 id="serialize操作符"><a href="#serialize操作符" class="headerlink" title="serialize操作符"></a><strong>serialize</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; serialize()</div></pre></td></tr></table></figure>
<p>他的作用主要是维持保证Observable能够正常的结束调用。比如，由于我们的Observable发射数据的时候可能是异步的，那么他们就存在着一种这样子的关系：我前面的数据正常调用onNext函数，然后在某一个异步中调用onComplete函数需要正常结束掉这个Observable，但是还有一些没有完成的异步任务，他们完成之后还会调用onNext函数，但是这回导致Observable的调用不正确，我们需要维持这个Observable正常结束，就可以使用serialize。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        ob.doOnUnsubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnUnsubscribe&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;s&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>这时候的输出是正常的，是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: A</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: B</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: C</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: onCompleted</div><div class="line">11-01 14:01:36.273 8186-8186/? I/RxJavaTest: doOnUnsubscribe</div></pre></td></tr></table></figure></p>
<p>这是正常的原因是Observer接受到onComplete的时候结束掉了订阅的关系，但是当我们使用<strong>unsafeSubscribe</strong>操作符，该操作符不会使得Observer主动结束订阅关系的时候去订阅Observable的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ob.doOnUnsubscribe(new Action0() &#123;</div><div class="line">           @Override</div><div class="line">           public void call() &#123;</div><div class="line">               Log.i(TAG, &quot;doOnUnsubscribe&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;).unsafeSubscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onCompleted() &#123;</div><div class="line">               Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line">               Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;s&quot;);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: C</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: onCompleted</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: D</div><div class="line">11-01 14:01:01.290 7672-7672/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>可以看到他是没有正常结束的，应该是发射了C之后就结束的，同时也没有调用unsafeSubscribe函数，这时候我们需要维持正常，就可以使用serialize谓词，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ob.doOnUnsubscribe(new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;doOnUnsubscribe&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;).serialize().subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e.getMessage());</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG,s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: C</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: onCompleted</div><div class="line">11-01 14:03:08.302 9525-9525/com.example.user.testproject I/RxJavaTest: doOnUnsubscribe</div></pre></td></tr></table></figure></p>
<p>这时候看到的是正常结束了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/serialize.c.png" alt=""></p>
<h6 id="ObserveOn操作符"><a href="#ObserveOn操作符" class="headerlink" title="ObserveOn操作符"></a><strong>ObserveOn</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler)</div><div class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler, int bufferSize)</div><div class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError)</div></pre></td></tr></table></figure>
<p>该操作符用于指定Observer在那个调度器上面去观察Observable，也就是Observable发射数据之后，在Observer中处理时候的线程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Log.i(TAG, Thread.currentThread().getName());</div><div class="line">        Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                Log.i(TAG, &quot;Observable&quot;+Thread.currentThread().getName());</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.observeOn(Schedulers.newThread()).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">                Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;, new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;Complete&quot;);</div><div class="line">                Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">11-01 14:30:00.235 882-882/com.example.user.testproject I/RxJavaTest: main</div><div class="line">11-01 14:30:00.263 882-882/com.example.user.testproject I/RxJavaTest: Observablemain</div><div class="line">11-01 14:30:00.264 882-910/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: C</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Complete</div><div class="line">11-01 14:30:00.267 882-910/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div></pre></td></tr></table></figure></p>
<p>可以看到Observer处理的线程就是我们通过observeOn操作符给他定义的线程<br>图：<br><img src="http://reactivex.io/documentation/operators/images/observeOn.c.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/observeOn.e.png" alt=""></p>
<h6 id="SubscribeOn操作符"><a href="#SubscribeOn操作符" class="headerlink" title="SubscribeOn操作符"></a><strong>SubscribeOn</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; subscribeOn(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>用于指定Observable运行call的时候的线程，或者说是Observable自身所在的线程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Log.i(TAG, Thread.currentThread().getName());</div><div class="line">       Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               Log.i(TAG, &quot;Observable = &quot;+Thread.currentThread().getName());</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread()).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-01 14:33:03.439 3927-3927/com.example.user.testproject I/RxJavaTest: main</div><div class="line">11-01 14:33:03.500 3927-3952/com.example.user.testproject I/RxJavaTest: Observable = RxNewThreadScheduler-1</div><div class="line">11-01 14:33:03.500 3927-3952/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:33:03.501 3927-3952/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div><div class="line">11-01 14:33:03.501 3927-3952/com.example.user.testproject I/RxJavaTest: Observer=RxNewThreadScheduler-1</div></pre></td></tr></table></figure></p>
<p>可以看到Observable所在的线程是我们给他指定的线程，Observer默认不在任何调度器上面执行，所以也跟着在这个线程上面执行，我们可以这样子指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Log.i(TAG, Thread.currentThread().getName());</div><div class="line">       Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               Log.i(TAG, &quot;Observable = &quot;+Thread.currentThread().getName());</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread())</div><div class="line">               .observeOn(AndroidSchedulers.mainThread())</div><div class="line">               .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;Observer=&quot; + Thread.currentThread().getName());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>这样子Observer就可以在指定的不用于Observable所在的线程，注意这里需要引入RxAdnroid。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/subscribeOn.c.png" alt=""></p>
<h6 id="subscribe操作符"><a href="#subscribe操作符" class="headerlink" title="subscribe操作符"></a><strong>subscribe</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Subscription subscribe() //只是需要让Observable和Observer发生关联，不需要处理Observable发射的数据</div><div class="line">Subscription subscribe(final Action1&lt;? super T&gt; onNext);// 只是接受OnNext数据</div><div class="line">Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError)// 只是接受onNext和onError数据</div><div class="line">Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted)// 接受全部事件数据</div><div class="line">Subscription subscribe(final Observer&lt;? super T&gt; observer)// 作用跟上面的类似，可以处理所有Observable发射的事件数据。</div></pre></td></tr></table></figure>
<p>就是平常我们使用最多的一个操作符，用于关联Observable和Observer。他的例子就不写了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/B.forEach.png" alt=""></p>
<h6 id="timeInterval操作符"><a href="#timeInterval操作符" class="headerlink" title="timeInterval操作符"></a><strong>timeInterval</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;TimeInterval&lt;T&gt;&gt; timeInterval()</div><div class="line">Observable&lt;TimeInterval&lt;T&gt;&gt; timeInterval(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>他的作用是把源Observable发射的数据T装换为一个TimeInterval<t>对象，存储有他的值和该源数据跟前一个Observable数据发射的时间间隔。<br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               for (int i = 1; i &lt; 5; i++) &#123;</div><div class="line">                   subscriber.onNext(&quot;&quot; + i);</div><div class="line">                   try &#123;</div><div class="line">                       Thread.sleep(i * 100);</div><div class="line">                   &#125; catch (InterruptedException e) &#123;</div><div class="line">                       e.printStackTrace();</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread()).timeInterval().map(new Func1&lt;TimeInterval&lt;String&gt;, String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call(TimeInterval&lt;String&gt; time) &#123;</div><div class="line">               Log.i(TAG, &quot;前后相差时间：&quot; + time.getIntervalInMilliseconds()+&quot;  值：&quot;+time.getValue());</div><div class="line">               return time.getValue();</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe();</div></pre></td></tr></table></figure></t></p>
<p>结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11-01 14:53:02.878 21735-21749/? I/RxJavaTest: 前后相差时间：2  值：1</div><div class="line">11-01 14:53:02.980 21735-21749/? I/RxJavaTest: 前后相差时间：102  值：2</div><div class="line">11-01 14:53:03.182 21735-21749/? I/RxJavaTest: 前后相差时间：202  值：3</div><div class="line">11-01 14:53:03.483 21735-21749/? I/RxJavaTest: 前后相差时间：301  值：4</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/timeInterval.c.png" alt=""></p>
<h6 id="Timeout操作符"><a href="#Timeout操作符" class="headerlink" title="Timeout操作符"></a><strong>Timeout</strong>操作符</h6><p>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit)</div><div class="line">Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler)</div></pre></td></tr></table></figure></p>
<p>该操作符在两个Observable数据发射之前的时间间隔超出了timeout，就会发射一个TimeoutException给Observer的onError。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                for (int i=1;i&lt;=4;i++) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(i * 200);</div><div class="line">                        subscriber.onNext(&quot;&quot; + i);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                try &#123;</div><div class="line">                    Thread.currentThread().sleep(2000);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.subscribeOn(Schedulers.newThread()).timeout(1,TimeUnit.SECONDS).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot;+e);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">11-01 15:20:03.978 13695-13710/? I/RxJavaTest: A</div><div class="line">11-01 15:20:04.181 13695-13710/? I/RxJavaTest: 1</div><div class="line">11-01 15:20:04.583 13695-13710/? I/RxJavaTest: 2</div><div class="line">11-01 15:20:05.183 13695-13710/com.example.user.testproject I/RxJavaTest: 3</div><div class="line">11-01 15:20:05.984 13695-13710/com.example.user.testproject I/RxJavaTest: 4</div><div class="line">11-01 15:20:06.985 13695-13709/com.example.user.testproject I/RxJavaTest: onErrorjava.util.concurrent.TimeoutException</div></pre></td></tr></table></figure></p>
<p>从这里可以看到是两个Observable数据发射的时间间隔，而不是总体的发射时间。<br><img src="http://reactivex.io/documentation/operators/images/timeout.2.png" alt=""><br>第二种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Observable&lt;? extends T&gt; other)</div><div class="line">Observable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Observable&lt;? extends T&gt; other, Scheduler scheduler)</div></pre></td></tr></table></figure></p>
<p>这个函数可以在超时之后发射一个Observable座位补充，他是接着在源的数据之后发射，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">              subscriber.onNext(&quot;A&quot;);</div><div class="line">              for (int i = 1; i &lt;= 4; i++) &#123;</div><div class="line">                  try &#123;</div><div class="line">                      Thread.sleep(i * 200);</div><div class="line">                      subscriber.onNext(&quot;&quot; + i);</div><div class="line">                  &#125; catch (InterruptedException e) &#123;</div><div class="line">                      e.printStackTrace();</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              try &#123;</div><div class="line">                  Thread.currentThread().sleep(2000);</div><div class="line">              &#125; catch (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              subscriber.onNext(&quot;B&quot;);</div><div class="line">              subscriber.onCompleted();</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      ob.subscribeOn(Schedulers.newThread()).timeout(1, TimeUnit.SECONDS, Observable.just(&quot;G&quot;)).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void onCompleted() &#123;</div><div class="line">              Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onError(Throwable e) &#123;</div><div class="line">              Log.i(TAG, &quot;onError&quot; + e);</div><div class="line">          &#125;</div><div class="line"> </div><div class="line">          @Override</div><div class="line">          public void onNext(String s) &#123;</div><div class="line">              Log.i(TAG, s);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">11-01 15:25:24.379 18453-18468/? I/RxJavaTest: A</div><div class="line">11-01 15:25:24.582 18453-18468/? I/RxJavaTest: 1</div><div class="line">11-01 15:25:24.983 18453-18468/? I/RxJavaTest: 2</div><div class="line">11-01 15:25:25.584 18453-18468/com.example.user.testproject I/RxJavaTest: 3</div><div class="line">11-01 15:25:26.385 18453-18468/com.example.user.testproject I/RxJavaTest: 4</div><div class="line">11-01 15:25:27.388 18453-18467/com.example.user.testproject I/RxJavaTest: G</div><div class="line">11-01 15:25:27.388 18453-18467/com.example.user.testproject I/RxJavaTest: onCompleted</div></pre></td></tr></table></figure></p>
<p>这样子就可以让Observable顺利发射完成。<br><img src="http://reactivex.io/documentation/operators/images/timeout3.png" alt=""><br>第三种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; timeout(Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector)</div><div class="line">Observable&lt;T&gt;  timeout(Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector, Observable&lt;? extends T&gt; other)</div></pre></td></tr></table></figure></p>
<p>这个谓词，他返回一个跟源Observable对应的Observable，当该谓词的Observable发射终止，源Observable还没有发射数据的时候，就发射一个TimeoutException给Observer的onError。第二个函数是不发射给onError，而是在源数据的基础之上继续发射替补的other。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.currentThread().sleep(100);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.subscribeOn(Schedulers.newThread()).timeout(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;String&gt; call(String s) &#123;</div><div class="line">                return Observable.just(s).delay(50, TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Subscriber&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onCompleted() &#123;</div><div class="line">                Log.i(TAG, &quot;onCompleted&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.i(TAG, &quot;onError&quot; + e);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            @Override</div><div class="line">            public void onNext(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11-01 15:36:21.216 28118-28142/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-01 15:36:21.217 28118-28142/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-01 15:36:21.270 28118-28147/com.example.user.testproject I/RxJavaTest: onErrorjava.util.concurrent.TimeoutException</div></pre></td></tr></table></figure></p>
<p>第二个函数也是类似的。<br><img src="http://reactivex.io/documentation/operators/images/timeout5.png" alt=""><br><img src="http://reactivex.io/documentation/operators/images/timeout4.png" alt=""><br>第四种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; timeout(Func0&lt;? extends Observable&lt;U&gt;&gt; firstTimeoutSelector, Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector)</div><div class="line">Observable&lt;T&gt; timeout(Func0&lt;? extends Observable&lt;U&gt;&gt; firstTimeoutSelector, Func1&lt;? super T, ? extends Observable&lt;V&gt;&gt; timeoutSelector, Observable&lt;? extends T&gt; other)</div></pre></td></tr></table></figure></p>
<p>这是可以给第一个Observable的数据设置超时，即当源Observable的第一个数据没有在firstTimeoutSelector的终止之前发射就会发射TimeoutException。其他的是跟上面类似，例子就不写了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/timeout6.png" alt=""></p>
<h6 id="Timestamp操作符"><a href="#Timestamp操作符" class="headerlink" title="Timestamp操作符"></a><strong>Timestamp</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Timestamped&lt;T&gt;&gt; timestamp()</div><div class="line">Observable&lt;Timestamped&lt;T&gt;&gt; timestamp(Scheduler scheduler)</div></pre></td></tr></table></figure>
<p>他的作用是把源数据包装一次，让它带有发射时间，包装之后的数据是Timestamped<t> ，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">               subscriber.onNext(&quot;A&quot;);</div><div class="line">               subscriber.onNext(&quot;B&quot;);</div><div class="line">               try &#123;</div><div class="line">                   Thread.currentThread().sleep(100);</div><div class="line">               &#125; catch (InterruptedException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125;</div><div class="line">               subscriber.onNext(&quot;C&quot;);</div><div class="line">               subscriber.onCompleted();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       ob.subscribeOn(Schedulers.newThread()).timestamp().subscribe(new Action1&lt;Timestamped&lt;String&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Timestamped&lt;String&gt; stringTimestamped) &#123;</div><div class="line">               Log.i(TAG, &quot;timestamp&quot; + stringTimestamped);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></t></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11-01 15:49:09.785 7365-7379/? I/RxJavaTest: timestampTimestamped(timestampMillis = 1478015349785, value = A)</div><div class="line">11-01 15:49:09.785 7365-7379/? I/RxJavaTest: timestampTimestamped(timestampMillis = 1478015349785, value = B)</div><div class="line">11-01 15:49:09.886 7365-7379/? I/RxJavaTest: timestampTimestamped(timestampMillis = 1478015349886, value = C)</div></pre></td></tr></table></figure></p>
<p>图：<br><img src="http://reactivex.io/documentation/operators/images/timestamp.c.png" alt=""></p>
<h6 id="Using操作符"><a href="#Using操作符" class="headerlink" title="Using操作符"></a><strong>Using</strong>操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; using(</div><div class="line">            final Func0&lt;Resource&gt; resourceFactory,</div><div class="line">            final Func1&lt;? super Resource, ? extends Observable&lt;? extends T&gt;&gt; observableFactory,</div><div class="line">            final Action1&lt;? super Resource&gt; disposeAction)</div><div class="line"></div><div class="line">Observable&lt;T&gt; using(</div><div class="line">            final Func0&lt;Resource&gt; resourceFactory,</div><div class="line">            final Func1&lt;? super Resource, ? extends Observable&lt;? extends T&gt;&gt; observableFactory,</div><div class="line">            final Action1&lt;? super Resource&gt; disposeAction, boolean disposeEagerly)</div></pre></td></tr></table></figure>
<p>创建一个只在Observable生命周期内存在的一次性资源，需要释放的资源，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Observable.using(new Func0&lt;String&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public String call() &#123;</div><div class="line">               // 创建资源</div><div class="line">               return &quot;Hello&quot;;</div><div class="line">           &#125;</div><div class="line">       &#125;, new Func1&lt;Object, Observable&lt;?&gt;&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Observable&lt;?&gt; call(Object o) &#123;</div><div class="line">               //创建资源对应的Observable对象</div><div class="line">               return Observable.just(o);</div><div class="line">           &#125;</div><div class="line">       &#125;, new Action1&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Object o) &#123;</div><div class="line">               // 释放资源</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Object&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Object o) &#123;</div><div class="line">               Log.i(TAG,o.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>其中第一个参数是创建资源，第二个参数是创建资源对应的Observable对象，第三个参数是释放资源。他适合与一些全局的一些需要被及时回收而我们需要确定他回收的资源。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/using.c.png" alt=""></p>
<h5 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h5><p>我们可以使用布尔操作符，对源数据Observable发送的数据进行变换或者是直接的布尔操作，来达到一些目的。</p>
<h6 id="all-操作符"><a href="#all-操作符" class="headerlink" title="all 操作符"></a><strong>all</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Boolean&gt; all(Func1&lt;? super T, Boolean&gt; predicate)</div></pre></td></tr></table></figure>
<p>用于判断Observable的所有数据是否满足某一个条件<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,3).all(new Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(Integer integer) &#123;</div><div class="line">               return integer&gt;9;</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Boolean aBoolean) &#123;</div><div class="line">               Log.i(TAG, &quot;all&quot; + aBoolean.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是true，加入把条件改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">            public Boolean call(Integer integer) &#123;</div><div class="line">                return integer&gt;11;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>那么就是输出false了。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/all.png" alt=""></p>
<h6 id="amb-操作符"><a href="#amb-操作符" class="headerlink" title="amb 操作符"></a><strong>amb</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; amb(Iterable&lt;? extends Observable&lt;? extends T&gt;&gt; sources)</div><div class="line">Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2)</div><div class="line">Observable&lt;T&gt; amb(Observable&lt;? extends T&gt; o1, Observable&lt;? extends T&gt; o2, Observable&lt;? extends T&gt; o3)</div><div class="line">...... 还有其他的，同样是上面哪样子的</div></pre></td></tr></table></figure>
<p>amb操作符的作用是用于比较两个Observable，然后哪一个先发射数据就只是发射这个Observable的数据，抛弃其他的Observable数据，不论他第一个是发射了onError还是onComplete，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; o1 = Observable.range(20, 1).delay(200, TimeUnit.MILLISECONDS);</div><div class="line">        Observable&lt;Integer&gt; o2 = Observable.range(10, 1).delay(100, TimeUnit.MILLISECONDS);</div><div class="line"> </div><div class="line">        Observable.amb(o1, o2).subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer integer) &#123;</div><div class="line">                Log.i(TAG, &quot;amb==&quot; + integer.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">amb==10</div></pre></td></tr></table></figure></p>
<p>有一个ambWith操作符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; ambWith(Observable&lt;? extends T&gt; t1)</div></pre></td></tr></table></figure></p>
<p>他是一个非静态的，作用跟上面的一样。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/amb.png" alt=""></p>
<h6 id="contains-操作符"><a href="#contains-操作符" class="headerlink" title="contains 操作符"></a><strong>contains</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Boolean&gt; contains(final Object element)</div></pre></td></tr></table></figure>
<p>该操作符的作用是用于判断源数据时候包含某一个元素，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.range(10,5).contains(11).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">         @Override</div><div class="line">         public void call(Boolean aBoolean) &#123;</div><div class="line">             Log.i(TAG,aBoolean.toString());</div><div class="line">         &#125;</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>输出是true，因为源数据的范围是10-14之间，包含11.<br>图：<br><img src="http://reactivex.io/documentation/operators/images/contains.png" alt=""></p>
<h6 id="defaultIfEmpty-操作符"><a href="#defaultIfEmpty-操作符" class="headerlink" title="defaultIfEmpty 操作符"></a><strong>defaultIfEmpty</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; defaultIfEmpty(final T defaultValue)</div></pre></td></tr></table></figure>
<p>该操作符的作用是在源Observable没有发射数据的时候发射一个默认数据，但是有onComplete()调用，表明他已经发射数据完毕，在没有数据发射的时候调用了onError是不会发射默认数据的，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> Observable&lt;String&gt; ob = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onCompleted();</div><div class="line">//                subscriber.onError(new IllegalArgumentException(&quot;error&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ob.defaultIfEmpty(&quot;A&quot;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>结果是：A，假如是发射onError的时候则是只输出“error”，而不会输出A<br>图：<br><img src="http://reactivex.io/documentation/operators/images/defaultIfEmpty.c.png" alt=""></p>
<h6 id="sequenceEqual-操作符"><a href="#sequenceEqual-操作符" class="headerlink" title="sequenceEqual 操作符"></a><strong>sequenceEqual</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Boolean&gt; sequenceEqual(Observable&lt;? extends T&gt; first, Observable&lt;? extends T&gt; second)</div><div class="line">Observable&lt;Boolean&gt; sequenceEqual(Observable&lt;? extends T&gt; first, Observable&lt;? extends T&gt; second, Func2&lt;? super T, ? super T, Boolean&gt; equality)</div></pre></td></tr></table></figure>
<p>第一个函数，用于判断输入的两个Observable是否相同，包括发射长度，顺序，值，终止状态，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.sequenceEqual(Observable.just(&quot;A&quot;,&quot;B&quot;),Observable.just(&quot;A&quot;,&quot;B&quot;)).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Boolean aBoolean) &#123;</div><div class="line">                Log.i(TAG, aBoolean.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出就是true，把第二个Observable改为Observable.just(“B”,”A”)，输出就是false。<br>终止状态不同的时候，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; o1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Observable&lt;String&gt; o2 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onError(new IllegalArgumentException(&quot;Error&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        Observable.sequenceEqual(o1,o2).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Boolean aBoolean) &#123;</div><div class="line">                Log.i(TAG, aBoolean.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line">                Log.i(TAG, throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>就会输出了error。<br>第二个函数，他多了一个参数，是用于比较，自己确定规则的那种比较，两个Observable的值是否相同。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable.sequenceEqual(Observable.just(&quot;A&quot;), Observable.just(&quot;A&quot;), new Func2&lt;String, String, Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public Boolean call(String s, String s2) &#123;</div><div class="line">               return s.equals(s2);</div><div class="line">           &#125;</div><div class="line">       &#125;).subscribe(new Action1&lt;Boolean&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void call(Boolean aBoolean) &#123;</div><div class="line">               Log.i(TAG, aBoolean.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure></p>
<p>就是输出true，<br>图：<br><img src="http://reactivex.io/documentation/operators/images/sequenceEqual.png" alt=""></p>
<h6 id="skipUntil-操作符"><a href="#skipUntil-操作符" class="headerlink" title="skipUntil 操作符"></a><strong>skipUntil</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; skipUntil(Observable&lt;U&gt; other)</div></pre></td></tr></table></figure>
<p>用于废弃源Observable，知道other操作符符发射数据，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; s1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onNext(&quot;E&quot;);</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(200);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        s1.subscribeOn(Schedulers.newThread())</div><div class="line">                .skipUntil(Observable.just(&quot;B&quot;)</div><div class="line">                .delay(100, TimeUnit.MILLISECONDS))</div><div class="line">                .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void call(String s) &#123;</div><div class="line">                        Log.i(TAG, s);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果是只输出了D，以为前面的C，E在other发射数据之前已经发射，所以会被丢弃。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/skipUntil.png" alt=""></p>
<h6 id="skipWhile-操作符"><a href="#skipWhile-操作符" class="headerlink" title="skipWhile 操作符"></a><strong>skipWhile</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; skipWhile(Func1&lt;? super T, Boolean&gt; predicate)</div></pre></td></tr></table></figure>
<p>他的作用在于可以自己定规则，忽略前面不符合条件的数据，但是当一旦返回了true，该数据就不会被发射，然后predicate谓词还是会被调用，但是当predicate返回了false之后就不会再次被调用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; s1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onNext(&quot;E&quot;);</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">                subscriber.onNext(&quot;F&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        s1.skipWhile(new Func1&lt;String, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;skipWhile&quot;);</div><div class="line">                return s.equals(&quot;C&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: skipWhile</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: skipWhile</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: E</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: D</div><div class="line">11-02 14:08:21.526 29654-29654/com.example.user.testproject I/RxJavaTest: F</div></pre></td></tr></table></figure></p>
<p>可以看到C没有输出，而且调用了skipWhile两次，skipWhile返回了false之后就没有被再次调用而是直接发射了源Observable后面的数据。<br>图：<br><img src="http://reactivex.io/documentation/operators/images/skipWhile.png" alt=""></p>
<h6 id="TakeUntil-操作符"><a href="#TakeUntil-操作符" class="headerlink" title="TakeUntil 操作符"></a><strong>TakeUntil</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; takeUntil(Observable&lt;? extends E&gt; other)</div></pre></td></tr></table></figure>
<p>他的作用在于other在发射一个数据或者是onComplete的时候，回去终止源Observable发射数据，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; o1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">          @Override</div><div class="line">          public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">              subscriber.onNext(&quot;A&quot;);</div><div class="line">              subscriber.onNext(&quot;B&quot;);</div><div class="line">              subscriber.onNext(&quot;C&quot;);</div><div class="line">              try &#123;</div><div class="line">                  Thread.sleep(200);</div><div class="line">              &#125; catch (InterruptedException e) &#123;</div><div class="line">                  e.printStackTrace();</div><div class="line">              &#125;</div><div class="line">              subscriber.onNext(&quot;D&quot;);</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      o1.subscribeOn(Schedulers.newThread())</div><div class="line">              .takeUntil(Observable.empty().delay(100, TimeUnit.MILLISECONDS))</div><div class="line">              .subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">                  @Override</div><div class="line">                  public void call(String s) &#123;</div><div class="line">                      Log.i(TAG, s);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11-02 14:24:02.505 11375-11396/com.example.user.testproject I/RxJavaTest: A</div><div class="line">11-02 14:24:02.505 11375-11396/com.example.user.testproject I/RxJavaTest: B</div><div class="line">11-02 14:24:02.505 11375-11396/com.example.user.testproject I/RxJavaTest: C</div></pre></td></tr></table></figure></p>
<p>可以看到other是在100ms之后再去发射数据的，observable在100ms之后发射的数据会被忽略。图：<br><img src="http://reactivex.io/documentation/operators/images/takeUntil.png" alt=""></p>
<h6 id="TakeWhile-操作符"><a href="#TakeWhile-操作符" class="headerlink" title="TakeWhile 操作符"></a><strong>TakeWhile</strong> 操作符</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable&lt;T&gt; takeWhile(final Func1&lt;? super T, Boolean&gt; predicate)</div></pre></td></tr></table></figure>
<p>他的作用是通过predicate函数返回一个boolean值，假如是返回了true，则发射该数据，但是一旦返回来false，就终止源Observable的发射，同时调用他的onComplete()方法，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; o1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</div><div class="line">                subscriber.onNext(&quot;A&quot;);</div><div class="line">                subscriber.onNext(&quot;B&quot;);</div><div class="line">                subscriber.onNext(&quot;C&quot;);</div><div class="line">                subscriber.onNext(&quot;D&quot;);</div><div class="line">                subscriber.onCompleted();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        o1.takeWhile(new Func1&lt;String, Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call(String s) &#123;</div><div class="line">                Log.i(TAG, &quot;takeWhile==&quot;+s);</div><div class="line">                return s.equals(&quot;C&quot;);</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(String s) &#123;</div><div class="line">                Log.i(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Action1&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Throwable throwable) &#123;</div><div class="line"> </div><div class="line">            &#125;</div><div class="line">        &#125;, new Action0() &#123;</div><div class="line">            @Override</div><div class="line">            public void call() &#123;</div><div class="line">                Log.i(TAG, &quot;OnComplete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==A</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: OnComplete</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==B</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==C</div><div class="line">11-02 14:32:00.313 18417-18417/com.example.user.testproject I/RxJavaTest: takeWhile==D</div></pre></td></tr></table></figure></p>
<p>因为第一个数据就使得predicate返回了false，所以终止了发射，假如predicate换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">           public Boolean call(String s) &#123;</div><div class="line">               Log.i(TAG, &quot;takeWhile==&quot; + s);</div><div class="line">               return !s.equals(&quot;E&quot;);</div><div class="line">           &#125;</div></pre></td></tr></table></figure></p>
<p>则会输出全部，图：<br><img src="http://reactivex.io/documentation/operators/images/takeWhile.c.png" alt=""></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RxJava操作符/" rel="tag">#RxJava操作符</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/16/资源学习/gitrerecommend/" rel="next" title="Git学习推荐">
                <i class="fa fa-chevron-left"></i> Git学习推荐
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/07/gradle/gradle-java1/" rel="prev" title="Gradle构建java程序一">
                Gradle构建java程序一 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/images/avatar.jpg"
               alt="rabbit" />
          <p class="site-author-name" itemprop="name">rabbit</p>
          <p class="site-description motion-element" itemprop="description">Android</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#RXJava好处"><span class="nav-number">1.</span> <span class="nav-text">RXJava好处</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RXJava相关依赖"><span class="nav-number">1.1.</span> <span class="nav-text">RXJava相关依赖</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RXJava的使用"><span class="nav-number">2.</span> <span class="nav-text">RXJava的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本概念"><span class="nav-number">2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#简单使用"><span class="nav-number">2.2.</span> <span class="nav-text">简单使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#详细"><span class="nav-number">2.3.</span> <span class="nav-text">详细</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Observable，就是一个需要被观察的对象，序列，生成的方式"><span class="nav-number">2.3.1.</span> <span class="nav-text">Observable，就是一个需要被观察的对象，序列，生成的方式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#create"><span class="nav-number">2.3.2.</span> <span class="nav-text">create</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#just"><span class="nav-number">2.3.3.</span> <span class="nav-text">just</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#from"><span class="nav-number">2.3.4.</span> <span class="nav-text">from</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Defer"><span class="nav-number">2.3.5.</span> <span class="nav-text">Defer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Interval"><span class="nav-number">2.3.6.</span> <span class="nav-text">Interval</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#range"><span class="nav-number">2.3.7.</span> <span class="nav-text">range</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#repeat"><span class="nav-number">2.3.8.</span> <span class="nav-text">repeat</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#timer"><span class="nav-number">2.3.9.</span> <span class="nav-text">timer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#empty-never-error"><span class="nav-number">2.3.10.</span> <span class="nav-text">empty ,never,error</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#变换操作符"><span class="nav-number">2.4.</span> <span class="nav-text">变换操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#map"><span class="nav-number">2.4.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#flatMap"><span class="nav-number">2.4.2.</span> <span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#concatMap"><span class="nav-number">2.4.3.</span> <span class="nav-text">concatMap</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#swichMap"><span class="nav-number">2.4.4.</span> <span class="nav-text">swichMap</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#case"><span class="nav-number">2.4.5.</span> <span class="nav-text">case</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#groupBy"><span class="nav-number">2.4.6.</span> <span class="nav-text">groupBy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Scan"><span class="nav-number">2.4.7.</span> <span class="nav-text">Scan</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#flatMapIterable"><span class="nav-number">2.4.8.</span> <span class="nav-text">flatMapIterable</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#buffer"><span class="nav-number">2.4.9.</span> <span class="nav-text">buffer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#window"><span class="nav-number">2.4.10.</span> <span class="nav-text">window</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#过滤操作符"><span class="nav-number">2.5.</span> <span class="nav-text">过滤操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#filter"><span class="nav-number">2.5.1.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#first"><span class="nav-number">2.5.2.</span> <span class="nav-text">first</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Debounce"><span class="nav-number">2.5.3.</span> <span class="nav-text">Debounce</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Distinct"><span class="nav-number">2.5.4.</span> <span class="nav-text">Distinct</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#elementAt"><span class="nav-number">2.5.5.</span> <span class="nav-text">elementAt</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#last"><span class="nav-number">2.5.6.</span> <span class="nav-text">last</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#skip"><span class="nav-number">2.5.7.</span> <span class="nav-text">skip</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#skipLast"><span class="nav-number">2.5.8.</span> <span class="nav-text">skipLast</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#take"><span class="nav-number">2.5.9.</span> <span class="nav-text">take</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#taskLast"><span class="nav-number">2.5.10.</span> <span class="nav-text">taskLast</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ignoreElements"><span class="nav-number">2.5.11.</span> <span class="nav-text">ignoreElements</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#last-1"><span class="nav-number">2.5.12.</span> <span class="nav-text">last</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sample操作符"><span class="nav-number">2.5.13.</span> <span class="nav-text">sample操作符</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#结合操作符"><span class="nav-number">2.6.</span> <span class="nav-text">结合操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CombineLatest-操作符"><span class="nav-number">2.6.1.</span> <span class="nav-text">CombineLatest 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#join组合操作符"><span class="nav-number">2.6.2.</span> <span class="nav-text">join组合操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#merge-组合操作符"><span class="nav-number">2.6.3.</span> <span class="nav-text">merge 组合操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#zip-组合操作符"><span class="nav-number">2.6.4.</span> <span class="nav-text">zip 组合操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#zipWith"><span class="nav-number">2.6.5.</span> <span class="nav-text">zipWith</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#switchOnNext"><span class="nav-number">2.6.6.</span> <span class="nav-text">switchOnNext</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#startWith"><span class="nav-number">2.6.7.</span> <span class="nav-text">startWith</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#错误处理操作符"><span class="nav-number">2.7.</span> <span class="nav-text">错误处理操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#catch操作符"><span class="nav-number">2.7.1.</span> <span class="nav-text">catch操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#retry操作符"><span class="nav-number">2.7.2.</span> <span class="nav-text">retry操作符</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#辅助操作符"><span class="nav-number">2.8.</span> <span class="nav-text">辅助操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#meterailize-Dematerialize-操作符"><span class="nav-number">2.8.1.</span> <span class="nav-text">meterailize/Dematerialize 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#delay-操作符"><span class="nav-number">2.8.2.</span> <span class="nav-text">delay 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#delaySubscription-操作符"><span class="nav-number">2.8.3.</span> <span class="nav-text">delaySubscription 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#do系列操作符"><span class="nav-number">2.8.4.</span> <span class="nav-text">do系列操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#serialize操作符"><span class="nav-number">2.8.5.</span> <span class="nav-text">serialize操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ObserveOn操作符"><span class="nav-number">2.8.6.</span> <span class="nav-text">ObserveOn操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SubscribeOn操作符"><span class="nav-number">2.8.7.</span> <span class="nav-text">SubscribeOn操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#subscribe操作符"><span class="nav-number">2.8.8.</span> <span class="nav-text">subscribe操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#timeInterval操作符"><span class="nav-number">2.8.9.</span> <span class="nav-text">timeInterval操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Timeout操作符"><span class="nav-number">2.8.10.</span> <span class="nav-text">Timeout操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Timestamp操作符"><span class="nav-number">2.8.11.</span> <span class="nav-text">Timestamp操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Using操作符"><span class="nav-number">2.8.12.</span> <span class="nav-text">Using操作符</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#布尔操作符"><span class="nav-number">2.9.</span> <span class="nav-text">布尔操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#all-操作符"><span class="nav-number">2.9.1.</span> <span class="nav-text">all 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#amb-操作符"><span class="nav-number">2.9.2.</span> <span class="nav-text">amb 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#contains-操作符"><span class="nav-number">2.9.3.</span> <span class="nav-text">contains 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#defaultIfEmpty-操作符"><span class="nav-number">2.9.4.</span> <span class="nav-text">defaultIfEmpty 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sequenceEqual-操作符"><span class="nav-number">2.9.5.</span> <span class="nav-text">sequenceEqual 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#skipUntil-操作符"><span class="nav-number">2.9.6.</span> <span class="nav-text">skipUntil 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#skipWhile-操作符"><span class="nav-number">2.9.7.</span> <span class="nav-text">skipWhile 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TakeUntil-操作符"><span class="nav-number">2.9.8.</span> <span class="nav-text">TakeUntil 操作符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#TakeWhile-操作符"><span class="nav-number">2.9.9.</span> <span class="nav-text">TakeWhile 操作符</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rabbit</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
